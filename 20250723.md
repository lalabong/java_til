
# Spring Framework의 빈(Bean): 객체 관리의 핵심

Spring을 이해하는 데 있어서 **빈(Bean)** 이라는 개념을 빼놓고는 얘기할 수 없습니다. 빈은 Spring의 심장이자 모든 것의 시작점이라고 해도 과언이 아니에요. 그런데 처음 Spring을 접하는 개발자들은 "왜 평범한 객체를 굳이 '빈'이라고 부르는 거지?"라고 의아해하는 경우가 많죠. 이 궁금증을 해결하면서 빈의 정체성과 등록 방법까지 쭉 알아보겠습니다.

## 빈(Bean)이란 정확히 무엇인가?

빈은 단순히 말하면 **Spring IoC 컨테이너가 관리하는 객체**입니다. 하지만 여기서 중요한 포인트는 '컨테이너가 관리한다'는 부분이에요.

일반적으로 우리가 `new` 키워드로 생성하는 객체와 빈의 가장 큰 차이점은 **생명주기 관리의 주체**입니다. 일반 객체는 개발자가 직접 생성하고 관리해야 하지만, 빈은 Spring 컨테이너가 대신 생성, 의존성 주입, 소멸까지 모든 과정을 책임져줍니다.

예를 들어, `UserService`라는 클래스가 있다고 해봅시다. 이것을 일반 객체로 사용한다면 매번 `new UserService()`로 생성해야 하고, 필요한 의존성들도 직접 넣어줘야 해요. 하지만 이것을 빈으로 등록하면 Spring이 알아서 생성하고, 필요한 곳에 주입해주고, 더 이상 필요 없을 때는 정리까지 해줍니다.

**빈의 핵심 특징들**

빈은 기본적으로 **싱글톤(Singleton) 패턴**으로 관리됩니다. 즉, 애플리케이션 전체에서 해당 타입의 빈은 단 하나의 인스턴스만 존재한다는 뜻이에요. 물론 필요에 따라 `@Scope` 어노테이션으로 다른 스코프를 지정할 수도 있지만, 대부분의 경우 싱글톤이면 충분합니다.

또한 빈들 사이의 **의존성 주입이 자동으로 이루어집니다**. `UserService`가 `UserRepository`에 의존한다면, Spring이 알아서 `UserRepository` 빈을 찾아서 주입해주죠. 이런 자동화 덕분에 개발자는 비즈니스 로직에만 집중할 수 있게 됩니다.

## 빈 등록의 다양한 방법들

Spring에서 객체를 빈으로 등록하는 방법은 시대에 따라 계속 발전해왔습니다. 각각의 방법마다 고유한 장점과 사용 상황이 있어요.

### 어노테이션 기반 등록: 가장 직관적인 방법

가장 많이 사용되는 방법은 **스테레오타입 어노테이션**을 클래스에 붙이는 것입니다.

```java
@Service
public class UserService {
    // 비즈니스 로직
}

@Repository
public class UserRepository {
    // 데이터 접근 로직
}

@Controller
public class UserController {
    // 웹 요청 처리
}

@Component
public class EmailSender {
    // 유틸리티 기능
}
```

**각 어노테이션의 의미와 역할**

`@Component`는 가장 기본적인 빈 등록 어노테이션입니다. 다른 스테레오타입 어노테이션들의 부모 격이죠. 특별한 역할이 없는 일반적인 컴포넌트에 사용합니다.

`@Service`는 비즈니스 로직을 담당하는 서비스 계층에 사용합니다. 기능적으로는 `@Component`와 동일하지만, 개발자와 도구들이 해당 클래스의 역할을 쉽게 파악할 수 있게 해주는 **의미론적 마킹** 역할을 합니다.

`@Repository`는 데이터 접근 계층에 사용하며, 추가로 **데이터베이스 예외를 Spring의 DataAccessException으로 변환**해주는 기능도 제공합니다.

`@Controller`는 웹 계층의 컨트롤러에 사용하며, Spring MVC에서 요청을 처리하는 핸들러로 인식됩니다.

### Java Configuration: 설정의 중앙화

`@Configuration` 클래스 안에서 `@Bean` 메서드를 정의하는 방식도 매우 유용합니다. 특히 **외부 라이브러리의 객체**를 빈으로 등록하거나, **복잡한 초기화 로직**이 필요한 경우에 적합해요.

```java
@Configuration
public class AppConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("user");
        dataSource.setPassword("password");
        return dataSource;
    }
    
    @Bean
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory());
        return restTemplate;
    }
}
```

이 방식의 장점은 **빈 생성 과정을 완전히 제어**할 수 있다는 점입니다. 복잡한 설정이나 조건부 빈 생성, 여러 인스턴스 중 하나를 선택하는 로직 등을 자유롭게 구현할 수 있어요.

### 자동 스캔: 편리함의 극치

`@ComponentScan` 어노테이션을 사용하면 지정된 패키지 하위의 모든 스테레오타입 어노테이션이 붙은 클래스들을 자동으로 빈으로 등록해줍니다.

```java
@SpringBootApplication // 내부에 @ComponentScan이 포함됨
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

Spring Boot를 사용한다면 `@SpringBootApplication` 어노테이션이 자동으로 컴포넌트 스캔을 활성화해주므로, 별도의 설정 없이도 패키지 구조만 잘 갖추면 모든 빈이 자동으로 등록됩니다.

## 빈 등록 시 알아두면 좋은 팁들

### 빈의 이름 지정하기

기본적으로 빈의 이름은 **클래스명의 첫 글자를 소문자로 바꾼 것**이 됩니다. `UserService` 클래스는 `userService`라는 이름의 빈이 되죠. 하지만 필요에 따라 직접 이름을 지정할 수도 있어요.

```java
@Service("myUserService")
public class UserService {
    // ...
}

@Bean("customDataSource")
public DataSource dataSource() {
    // ...
}
```


### 조건부 빈 등록

`@ConditionalOnProperty`, `@ConditionalOnClass` 같은 어노테이션을 사용하면 특정 조건을 만족할 때만 빈을 등록할 수 있습니다.

```java
@Component
@ConditionalOnProperty(name = "feature.email.enabled", havingValue = "true")
public class EmailService {
    // 이메일 기능이 활성화된 경우에만 빈으로 등록
}
```


### 우선순위와 Primary

같은 타입의 빈이 여러 개 있을 때는 `@Primary` 어노테이션으로 기본 빈을 지정하거나, `@Qualifier`로 특정 빈을 명시할 수 있습니다.

```java
@Service
@Primary
public class PrimaryUserService implements UserService {
    // 기본으로 사용될 구현체
}

@Service
@Qualifier("advanced")
public class AdvancedUserService implements UserService {
    // 고급 기능 구현체
}
```


## 실무에서의 빈 등록 전략

실제 프로젝트에서는 **어노테이션 방식과 Java Configuration을 적절히 혼합**해서 사용하는 것이 일반적입니다.

우리가 직접 작성한 클래스들은 `@Service`, `@Repository` 같은 어노테이션으로 간단하게 등록하고, 외부 라이브러리나 복잡한 설정이 필요한 객체들은 `@Configuration` 클래스에서 `@Bean` 메서드로 등록하는 방식이죠.

또한 **환경별로 다른 구현체**를 사용해야 하는 경우에는 Spring Profile과 조건부 빈 등록을 활용해서 깔끔하게 처리할 수 있습니다.

빈이라는 개념이 처음에는 복잡해 보일 수 있지만, 한 번 익숙해지면 Spring의 강력한 IoC 컨테이너 덕분에 훨씬 더 깔끔하고 유지보수하기 좋은 코드를 작성할 수 있게 됩니다. 특히 테스트 코드를 작성할 때 빈 등록의 진가가 더욱 빛을 발하죠.

## 느낀 점
의존성 주입 부분은 봐도봐도 어렵다. 이해하기 힘들어서 많이 보고 복습해야겠다....
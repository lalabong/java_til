
# JPA 영속성 컨텍스트와 엔티티 생명주기

영속성 컨텍스트는 JPA를 이해하는 핵심 개념입니다. 이 가상의 저장 공간에서 엔티티들이 어떻게 관리되고 변화하는지 실무 중심으로 정리해보겠습니다.

## 영속성 컨텍스트란?

**영속성 컨텍스트(Persistence Context)** 는 **엔티티를 영구 저장하는 환경**을 의미합니다. 쉽게 말해 EntityManager와 데이터베이스 사이에 존재하는 **가상의 저장 공간**이라고 생각하면 됩니다.

### 핵심 특징

**1차 캐시 역할**

```java
// 같은 ID로 조회하면 1차 캐시에서 반환 (DB 조회 X)
User user1 = em.find(User.class, 1L);
User user2 = em.find(User.class, 1L); // DB 조회 안 함
System.out.println(user1 == user2); // true (동일성 보장)
```

**변경 감지(Dirty Checking)**

```java
User user = em.find(User.class, 1L);
user.setName("변경된 이름"); // 단순 setter 호출만으로
// commit 시점에 자동으로 UPDATE 쿼리 실행
```

**지연 로딩과 즉시 로딩**

```java
@Entity
public class User {
    @OneToMany(fetch = FetchType.LAZY) // 필요할 때 로딩
    private List<Order> orders;
}
```


## 엔티티의 4가지 상태

### 1. 비영속(Transient)

```java
// 객체만 생성한 상태, JPA와 전혀 관계없음
User user = new User();
user.setName("김개발");
```


### 2. 영속(Managed)

```java
// EntityManager에 의해 관리되는 상태
em.persist(user); // 영속 상태로 만듦
User foundUser = em.find(User.class, 1L); // 조회된 엔티티도 영속 상태
```


### 3. 준영속(Detached)

```java
em.detach(user);    // 특정 엔티티만 분리
em.clear();         // 영속성 컨텍스트 전체 초기화
em.close();         // EntityManager 종료
```


### 4. 삭제(Removed)

```java
User user = em.find(User.class, 1L);
em.remove(user); // 삭제 상태, commit 시 DELETE 쿼리 실행
```


## 엔티티 생명주기 흐름도

```
비영속(New) → persist() → 영속(Managed) → detach() → 준영속(Detached)
                ↓                           ↑
              commit()                   merge()
                ↓                           ↑
            데이터베이스 ← remove() ← 삭제(Removed)
```


## 실무에서 자주 사용하는 패턴들

### 영속성 컨텍스트 활용 패턴

**더티 체킹을 활용한 업데이트**

```java
@Transactional
public void updateUser(Long userId, String newName) {
    User user = userRepository.findById(userId).orElseThrow();
    user.setName(newName); // 더티 체킹으로 자동 UPDATE
    // repository.save() 호출 불필요!
}
```

**1차 캐시 활용으로 성능 최적화**

```java
@Transactional
public void processUsers() {
    User user1 = em.find(User.class, 1L); // DB 조회
    User user2 = em.find(User.class, 1L); // 1차 캐시에서 반환
    
    // 같은 트랜잭션 내에서는 동일성 보장
    assert user1 == user2;
}
```


### 주의해야 할 상황들

**준영속 상태에서의 변경 감지 불가**

```java
@Transactional
public User getUserForUpdate(Long id) {
    return userRepository.findById(id).orElseThrow();
} // 트랜잭션 종료, 엔티티는 준영속 상태

// 다른 곳에서
User user = userService.getUserForUpdate(1L);
user.setName("변경"); // 변경 감지 안 됨!

// 해결법: merge() 사용
@Transactional
public void updateDetachedUser(User user) {
    User managedUser = em.merge(user); // 다시 영속 상태로
    managedUser.setName("변경"); // 이제 변경 감지됨
}
```


## 실전 사례: 게시판 서비스

```java
@Service
@Transactional
public class PostService {
    
    @Autowired
    private EntityManager em;
    
    public void createPost(PostCreateDto dto) {
        // 1. 비영속 상태
        Post post = new Post(dto.getTitle(), dto.getContent());
        
        // 2. 영속 상태로 전환
        em.persist(post);
        
        // 3. 트랜잭션 commit 시 INSERT 쿼리 실행
    }
    
    public void updatePost(Long postId, String newTitle) {
        // 1. 영속 상태로 조회
        Post post = em.find(Post.class, postId);
        
        // 2. 더티 체킹으로 자동 UPDATE
        post.updateTitle(newTitle);
        
        // em.persist() 또는 repository.save() 불필요!
    }
    
    public void deletePost(Long postId) {
        Post post = em.find(Post.class, postId);
        em.remove(post); // 삭제 상태로 전환
        // commit 시 DELETE 쿼리 실행
    }
}
```


## 성능 최적화 팁

### 1차 캐시 효과적 활용

```java
@Transactional
public void bulkProcess() {
    // 한 트랜잭션 내에서 반복 조회 시 1차 캐시 활용
    for (Long id : userIds) {
        User user = em.find(User.class, id); // 두 번째부터는 캐시에서
        processUser(user);
    }
}
```


### 플러시 타이밍 조절

```java
@Transactional
public void optimizeFlush() {
    // 대량 INSERT 전에 수동 플러시
    for (int i = 0; i < 1000; i++) {
        em.persist(new User("user" + i));
        if (i % 100 == 0) {
            em.flush(); // 100개씩 나누어 플러시
            em.clear(); // 1차 캐시 정리
        }
    }
}
```


## 트러블슈팅 가이드

### LazyInitializationException 해결

```java
// 문제 상황
@Transactional
public User getUser(Long id) {
    return userRepository.findById(id).orElseThrow();
} // 트랜잭션 종료, 엔티티 준영속 상태

// 준영속 상태에서 지연 로딩 시도 시 예외 발생
User user = userService.getUser(1L);
user.getOrders().size(); // LazyInitializationException!

// 해결법 1: 페치 조인 사용
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
User findByIdWithOrders(@Param("id") Long id);

// 해결법 2: @Transactional 범위 확장
@Transactional(readOnly = true)
public UserDto getUserWithOrders(Long id) {
    User user = userRepository.findById(id).orElseThrow();
    return UserDto.from(user, user.getOrders()); // 트랜잭션 내에서 초기화
}
```


## 느낀 점 및 마무리

영속성 컨텍스트는 JPA의 핵심이자 강력한 기능입니다. **1차 캐시를 통한 성능 향상**, **더티 체킹을 통한 편리한 업데이트**, **동일성 보장** 등의 장점을 제공하지만, 엔티티의 상태 변화를 정확히 이해해야 제대로 활용할 수 있습니다.

특히 실무에서는 트랜잭션 경계와 엔티티 상태를 항상 의식하면서 개발해야 예상치 못한 버그를 방지할 수 있어요. 영속성 컨텍스트를 마스터하면 JPA를 훨씬 더 효과적으로 사용할 수 있게 됩니다.




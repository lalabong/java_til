
# Spring Framework의 의존성 주입: 세 가지 방법의 모든 것

의존성 주입(Dependency Injection)은 Spring Framework의 핵심 기능 중 하나입니다. 객체 간의 결합도를 낮추고 유연한 애플리케이션을 만들기 위해 꼭 필요한 개념이죠. Spring에서는 크게 **세 가지 방법**으로 의존성을 주입할 수 있는데, 각각 고유한 특징과 적합한 사용 상황이 있습니다.

## 생성자 주입(Constructor Injection): 가장 권장되는 방식

생성자 주입은 말 그대로 **클래스의 생성자를 통해 의존성을 주입받는 방식**입니다. Spring에서 가장 권장하는 방법이기도 해요.

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
}
```

**생성자 주입의 강력한 장점들**

가장 큰 장점은 **불변성(Immutability)** 을 보장한다는 점입니다. `final` 키워드를 사용할 수 있어서 한 번 주입된 의존성이 변경될 수 없습니다. 이는 애플리케이션의 안정성을 크게 높여주죠.

또한 **순환 참조를 컴파일 시점에 발견**할 수 있습니다. A 클래스가 B를 참조하고 B가 다시 A를 참조하는 상황에서, 생성자 주입을 사용하면 애플리케이션 시작 시점에 바로 오류가 발생해서 문제를 빨리 찾을 수 있어요.

**필수 의존성을 명확하게 표현**할 수 있다는 것도 중요한 특징입니다. 생성자에 포함된 매개변수들은 모두 반드시 필요한 의존성이라는 메시지를 전달하죠.

Spring 4.3부터는 생성자가 하나뿐이라면 `@Autowired` 어노테이션도 생략할 수 있어서 코드가 더욱 깔끔해집니다.

## 필드 주입(Field Injection): 간단하지만 주의가 필요한 방식

필드 주입은 **클래스의 필드에 직접 `@Autowired`를 붙여서 의존성을 주입받는 방식**입니다. 코드가 매우 간결해 보여서 초보 개발자들이 선호하는 경우가 많아요.

```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
}
```

**편리하지만 숨겨진 단점들**

코드는 확실히 간단해 보이지만, 실제로는 여러 문제점이 있습니다. 가장 큰 문제는 **테스트하기 어렵다**는 점입니다. Spring 컨테이너 없이는 의존성을 주입할 방법이 없어서 단위 테스트 작성이 복잡해집니다.

또한 **순환 참조 문제를 런타임에서야 발견**할 수 있습니다. 애플리케이션이 시작되고 실제로 해당 빈을 사용할 때가 되어서야 오류가 발생하죠.

`final` 키워드를 사용할 수 없어서 **불변성도 보장되지 않습니다**. 그리고 의존성이 많을 때 클래스가 과도한 책임을 지고 있다는 신호를 놓치기 쉬워집니다.

## 수정자 주입(Setter Injection): 선택적 의존성을 위한 방식

수정자 주입은 **setter 메서드를 통해 의존성을 주입받는 방식**입니다. 주로 선택적(Optional) 의존성을 처리할 때 사용합니다.

```java
@Service
public class UserService {
    private UserRepository userRepository;
    private EmailService emailService;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Autowired(required = false)
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}
```

**유연성이 필요할 때의 선택**

수정자 주입의 가장 큰 특징은 **선택적 의존성 처리**가 가능하다는 점입니다. `@Autowired(required = false)`를 사용하면 해당 빈이 존재하지 않아도 애플리케이션이 정상적으로 동작합니다.

또한 **런타임에 의존성을 변경**할 수 있어서, 특정 상황에서는 이런 유연성이 필요할 수도 있어요. 하지만 대부분의 경우에는 이런 유연성이 오히려 버그의 원인이 될 수 있어서 신중하게 사용해야 합니다.

## 실무에서는 어떤 방식을 선택해야 할까?

**대부분의 상황에서는 생성자 주입을 사용하는 것이 정답**입니다. Spring 공식 문서에서도 생성자 주입을 권장하고 있고, 실제로 많은 장점들이 있어요.

필수적인 의존성은 생성자 주입으로, 정말 선택적인 의존성만 수정자 주입으로 처리하는 **혼합 방식**도 고려해볼 만합니다. 하지만 대부분의 경우 모든 의존성을 필수로 간주하고 생성자 주입만 사용해도 충분합니다.

필드 주입은 **테스트 코드나 간단한 예제**에서만 사용하고, 실제 프로덕션 코드에서는 피하는 것이 좋습니다.

## 최근 트렌드: Lombok과 함께하는 더 깔끔한 코드

요즘은 Lombok의 `@RequiredArgsConstructor`를 함께 사용해서 생성자 주입 코드를 더욱 간결하게 작성하는 것이 일반적입니다.

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    // 생성자가 자동으로 생성됨
}
```

이런 방식을 사용하면 생성자 주입의 모든 장점을 유지하면서도 코드는 필드 주입만큼 간결하게 작성할 수 있어요.

결국 의존성 주입 방식의 선택은 **안정성과 유연성 사이의 균형**을 찾는 문제입니다. 하지만 대부분의 상황에서는 안정성이 더 중요하기 때문에, 생성자 주입을 기본으로 하되 정말 필요한 경우에만 다른 방식을 고려하는 것이 현명한 선택입니다.

## 느낀 점
이번 프로젝트에서도 Lombok을 이용한 생성자 주입을 사용하고 있었는데 좋은 방향이라 다행이다.
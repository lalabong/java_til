# JPA N+1 문제

JPA를 사용하다 보면 성능 문제의 주범으로 꼽히는 N+1 문제를 반드시 마주하게 됩니다. 이 문제의 본질을 이해하고 효과적인 해결 전략을 실무 중심으로 정리해보겠습니다.

## N+1 문제란?

**N+1 문제**는 **1번의 쿼리로 N개의 데이터를 조회했는데, 연관된 데이터를 조회하기 위해 추가로 N번의 쿼리가 더 실행되는 문제**입니다.

### 문제 발생 시나리오

```java
@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;
    
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Order> orders = new ArrayList<>();
}

@Entity  
public class Order {
    @Id @GeneratedValue
    private Long id;
    private String product;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}
```

**문제가 발생하는 코드:**

```java
// 1. 모든 사용자 조회 (1번의 쿼리)
List<User> users = userRepository.findAll();

// 2. 각 사용자의 주문 목록 조회 (N번의 추가 쿼리)
for (User user : users) {
    System.out.println("사용자: " + user.getName());
    System.out.println("주문 수: " + user.getOrders().size()); // 여기서 추가 쿼리 발생!
}
```

**실행되는 SQL:**

```sql
-- 1번째 쿼리:
SELECT * FROM orders WHERE user_id = 2;
SELECT * FROM orders WHERE user_id = 3;
-- ... (사용자 수만큼 반복)
```


## N+1 문제 발생 원인

### 1. 지연 로딩(Lazy Loading)의 특성

```java
@OneToMany(fetch = FetchType.LAZY) // 기본값
private List<Order> orders;
```

- 연관된 엔티티는 **실제 사용될 때까지 로딩을 미룸**
- `getOrders().size()` 호출 시점에 각각 개별 쿼리 실행


### 2. 영속성 컨텍스트의 1차 캐시 한계

```java
// 같은 사용자를 여러 번 조회해도 추가 쿼리는 안 나감
User user1 = em.find(User.class, 1L);
User user2 = em.find(User.class, 1L); // 1차 캐시에서 반환

// 하지만 연관 엔티티는 각각 별도 쿼리
user1.getOrders().size(); // SELECT * FROM orders WHERE user_id = 1
user2.getOrders().size(); // 1차 캐시 활용 불가, 다시 쿼리 실행
```


## 해결 전략 1: 페치 조인(Fetch Join)

### JPQL 페치 조인

```java
// Repository 메서드
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();

// 사용
List<User> users = userRepository.findAllWithOrders();
for (User user : users) {
    user.getOrders().size(); // 추가 쿼리 없음!
}
```

**실행되는 SQL:**

```sql
-- 한 번의 조인 쿼리로 모든 데이터 조회
SELECT u.*, o.* 
FROM user u 
JOIN orders o ON u.id = o.user_id;
```


### 컬렉션 페치 조인 주의사항

```java
// ❌ 문제: 중복 데이터 발생
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders(); // User가 주문 수만큼 중복 조회됨

// ✅ 해결: DISTINCT 사용
@Query("SELECT DISTINCT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();

// ✅ 또는 Set 사용으로 중복 제거
@Query("SELECT u FROM User u JOIN FETCH u.orders")
Set<User> findAllWithOrdersAsSet();
```


## 해결 전략 2: @EntityGraph

### 기본 사용법

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    @EntityGraph(attributePaths = "orders")
    List<User> findAll();
    
    @EntityGraph(attributePaths = {"orders", "orders.items"})
    @Query("SELECT u FROM User u WHERE u.status = :status")
    List<User> findByStatusWithOrdersAndItems(@Param("status") String status);
}
```


### 동적 EntityGraph

```java
@EntityGraph(attributePaths = "orders")
@Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
List<User> findByNameContainingWithOrders(@Param("name") String name);
```


## 해결 전략 3: @BatchSize

### 컬렉션 배치 로딩

```java
@Entity
public class User {
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    @BatchSize(size = 10) // 10개씩 묶어서 조회
    private List<Order> orders = new ArrayList<>();
}
```

**효과:**

```sql
-- N+1 문제 발생 시
SELECT * FROM orders WHERE user_id = 1;
SELECT * FROM orders WHERE user_id = 2;
-- ...

-- @BatchSize 적용 시  
SELECT * FROM orders WHERE user_id IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
```


### 글로벌 배치 사이즈 설정

```yaml
# application.yml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```


## 해결 전략 4: 프로젝션과 DTO 활용

### 필요한 데이터만 조회

```java
// DTO 정의
public class UserOrderSummaryDto {
    private String userName;
    private Long orderCount;
    
    public UserOrderSummaryDto(String userName, Long orderCount) {
        this.userName = userName;
        this.orderCount = orderCount;
    }
}

// Repository 메서드
@Query("SELECT new com.example.dto.UserOrderSummaryDto(u.name, COUNT(o)) " +
       "FROM User u LEFT JOIN u.orders o GROUP BY u.id, u.name")
List<UserOrderSummaryDto> findUserOrderSummaries();
```


### 인터페이스 기반 프로젝션

```java
public interface UserOrderProjection {
    String getName();
    Long getOrderCount();
}

@Query("SELECT u.name as name, COUNT(o) as orderCount " +
       "FROM User u LEFT JOIN u.orders o GROUP BY u.id, u.name")
List<UserOrderProjection> findUserOrderProjections();
```


## 실전 적용 가이드

### 상황별 최적 전략

**1. 소량 데이터 + 모든 연관 데이터 필요**

```java
@EntityGraph(attributePaths = "orders")
List<User> findAll(); // EntityGraph 사용
```

**2. 대량 데이터 + 부분적 연관 데이터 접근**

```java
@BatchSize(size = 50)
private List<Order> orders; // BatchSize 사용
```

**3. 복합 연관 관계**

```java
@Query("SELECT DISTINCT u FROM User u " +
       "JOIN FETCH u.orders o " +
       "JOIN FETCH o.items")
List<User> findAllWithOrdersAndItems(); // 페치 조인
```

**4. 통계성 데이터**

```java
@Query("SELECT new UserSummaryDto(u.name, COUNT(o), SUM(o.amount)) " +
       "FROM User u LEFT JOIN u.orders o GROUP BY u.id")
List<UserSummaryDto> findUserSummaries(); // DTO 프로젝션
```


### 성능 측정과 모니터링

```java
@Configuration
public class JpaConfig {
    
    @Bean
    public HibernatePropertiesCustomizer hibernatePropertiesCustomizer() {
        return (properties) -> {
            // SQL 로깅 활성화
            properties.put("hibernate.show_sql", true);
            properties.put("hibernate.format_sql", true);
            
            // 쿼리 통계 수집
            properties.put("hibernate.generate_statistics", true);
        };
    }
}
```


## 주의사항과 트레이드오프

### 페치 조인의 한계

```java
// ❌ 페이징과 함께 사용 시 메모리 로딩
@Query("SELECT DISTINCT u FROM User u JOIN FETCH u.orders")
Page<User> findAllWithOrders(Pageable pageable); // 경고 발생

// ✅ 대안: 배치 사이즈 + 페이징
@BatchSize(size = 100)
private List<Order> orders;
```


### 카테시안 곱 문제

```java
// ❌ 여러 컬렉션 동시 페치 조인
@Query("SELECT u FROM User u " +
       "JOIN FETCH u.orders " +
       "JOIN FETCH u.addresses") // 데이터 폭증!

// ✅ 단계적 로딩 또는 별도 쿼리
@EntityGraph(attributePaths = "orders")
List<User> findAllWithOrders();

@EntityGraph(attributePaths = "addresses")  
List<User> findAllWithAddresses();
```


## 느낀 점 및 마무리

N+1 문제는 JPA 성능 최적화의 핵심 이슈입니다. **페치 조인**, **@EntityGraph**, **@BatchSize**, **DTO 프로젝션** 등 다양한 해결 전략을 상황에 맞게 선택해야 합니다.

가장 중요한 것은 **실제 SQL 로그를 확인하며 개발**하는 습관입니다. `hibernate.show_sql=true` 설정으로 쿼리를 모니터링하고, 성능 테스트를 통해 최적의 전략을 선택하세요.

각 해결 방법은 트레이드오프가 있으므로, 데이터 특성과 사용 패턴을 고려해 적절한 전략을 조합해 사용하는 것이 실무에서의 핵심입니다.


# 싱글 스레드 vs 멀티 스레드

## 스레드가 뭘까?

프로그램이 실행되면 프로세스가 생긴다. 그 프로세스 안에서 실제 작업을 수행하는 실행 단위가 스레드다. 쉽게 말해서 "일꾼"이라고 생각하면 된다.

싱글 스레드는 일꾼이 한 명, 멀티 스레드는 일꾼이 여러 명인 상황이다. 언뜻 보면 일꾼이 많을수록 좋을 것 같지만, 실제로는 그렇게 단순하지 않다.

## 싱글 스레드의 장점

### 단순함이 최고의 장점

싱글 스레드는 예측 가능하다. 코드가 위에서 아래로 순서대로 실행된다. 디버깅할 때도 실행 흐름을 따라가기 쉽다.

```javascript
function processData() {
    const data = fetchData();      // 1번
    const processed = transform(data);  // 2번
    saveToDatabase(processed);     // 3번
}
```

이 코드는 1→2→3 순서로 실행된다는 것을 보장할 수 있다.

### 메모리 공유 문제가 없다

여러 스레드가 같은 변수에 동시에 접근할 때 생기는 문제들(Race Condition, Deadlock 등)이 아예 없다. 전역 변수를 마음껏 쓸 수 있고, 동기화를 고민할 필요가 없다.

### 컨텍스트 스위칭 비용 없음

OS가 스레드를 바꿔가며 실행할 때 발생하는 오버헤드가 없다. CPU를 100% 내 작업에만 쓸 수 있다.

## 싱글 스레드의 한계

### CPU 하나만 쓴다

요즘 컴퓨터는 멀티 코어인데, 싱글 스레드는 코어 하나만 사용한다. 8코어 CPU에서 12.5%만 사용하는 셈이다.

### 블로킹이 치명적

파일 읽기, 네트워크 요청 등 I/O 작업을 하면 그 동안 프로그램이 멈춘다. 사용자는 "프로그램이 죽었나?"라고 생각할 수 있다.

```python
# 이런 코드가 있다면
data1 = download_file("big_file_1.zip")  # 10초 걸림
data2 = download_file("big_file_2.zip")  # 10초 걸림
# 총 20초 걸린다
```


## 멀티 스레드의 장점

### 진짜 병렬 처리

CPU 코어를 여러 개 쓸 수 있다. 계산 집약적인 작업을 여러 스레드로 나누면 실제로 빨라진다.

```python
# 큰 배열을 4개 스레드로 나눠서 처리
# 4코어에서 거의 4배 빨라질 수 있다
def parallel_sum(array):
    chunk_size = len(array) // 4
    # 각 스레드가 1/4씩 담당
```


### 논블로킹 처리

하나의 스레드가 I/O를 기다리는 동안 다른 스레드가 계속 일할 수 있다. 사용자 인터페이스도 반응성이 좋아진다.

### 처리량 증가

웹 서버를 예로 들면, 동시에 여러 요청을 처리할 수 있다. 한 요청이 데이터베이스를 기다리는 동안 다른 요청들을 처리한다.

## 멀티 스레드의 함정

### Race Condition

두 스레드가 같은 변수에 동시에 접근하면 예상치 못한 결과가 나올 수 있다.

```c
int counter = 0;

// 스레드 A, B가 동시에 이 함수를 실행하면?
void increment() {
    counter++;  // 실제로는 3단계: read, add, write
}
```

둘 다 0을 읽어서 1을 쓰면, 2번 증가했는데 결과는 1이 된다.

### Deadlock

두 스레드가 서로 가진 자원을 기다리며 멈춰버리는 상황이다.

```
스레드 A: 자원1을 잠그고 → 자원2를 기다림
스레드 B: 자원2를 잠그고 → 자원1을 기다림
결과: 둘 다 영원히 기다림
```


### 디버깅의 악몽

버그가 간헐적으로 발생한다. 실행할 때마다 스레드 실행 순서가 다를 수 있어서 "내 컴퓨터에서는 잘 되는데?"라는 상황이 생긴다.

## 언어별 접근 방식

### JavaScript: 이벤트 루프

JavaScript는 싱글 스레드지만 비동기 처리로 블로킹 문제를 해결한다.

```javascript
// 이렇게 하면 동시에 실행됨
Promise.all([
    fetch('/api/data1'),
    fetch('/api/data2'),
    fetch('/api/data3')
]);
```


### Python: GIL의 제약

Python은 GIL(Global Interpreter Lock) 때문에 CPU 집약적 작업에서는 멀티 스레드 효과가 제한적이다. I/O 작업에서만 유리하다.

### Java: 완전한 멀티 스레딩

JVM이 스레드를 OS 스레드에 1:1로 매핑해서 진짜 병렬 처리가 가능하다.

### Go: 고루틴

경량 스레드인 고루틴을 수백만 개까지 만들 수 있다. OS 스레드보다 훨씬 가볍다.

## 실전에서의 선택

### 싱글 스레드가 나은 경우

- 간단한 스크립트나 배치 작업
- I/O가 적은 CPU 집약적 작업 (단, 병렬화가 어려운 경우)
- 프로토타이핑이나 빠른 개발이 필요한 경우
- 데이터 일관성이 매우 중요한 경우


### 멀티 스레드가 필요한 경우

- 웹 서버나 네트워크 서비스
- 대용량 데이터 처리
- 사용자 인터페이스 (UI는 반응성이 중요)
- 병렬화 가능한 계산 작업


## 최적화 전략

### 스레드 풀 사용

스레드를 만들고 없애는 비용을 줄이기 위해 미리 만들어둔 스레드들을 재사용한다.

### Lock-Free 프로그래밍

뮤텍스 대신 원자적 연산을 사용해서 성능을 높인다. 하지만 구현이 매우 어렵다.

### 비동기 I/O

스레드를 늘리는 대신 이벤트 기반 처리를 사용한다. Node.js나 Python의 asyncio가 이 방식이다.

## 성능 측정의 중요성

"멀티 스레드가 무조건 빠르다"는 착각을 하면 안 된다. 실제로 측정해봐야 한다.

- **지연시간(Latency)**: 하나의 작업이 완료되는 시간
- **처리량(Throughput)**: 단위 시간당 처리 가능한 작업 수
- **리소스 사용량**: CPU, 메모리 사용률

때로는 싱글 스레드가 멀티 스레드보다 빠를 수도 있다. 특히 컨텍스트 스위칭 비용이 실제 작업 시간보다 클 때 그렇다.

결국 "은총알"은 없다. 상황에 맞는 선택이 중요하다. 단순한 작업에는 싱글 스레드로 충분하고, 복잡한 시스템에서는 멀티 스레드의 복잡성을 감수하고 성능을 얻어야 한다.


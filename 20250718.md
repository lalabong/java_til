
# JVM(Java Virtual Machine)

## JVM이란?

JVM은 **Java Virtual Machine**의 줄임말로, Java 바이트코드를 실행하는 가상의 컴퓨터입니다. 쉽게 말해서 운영체제와 Java 프로그램 사이의 중간 다리 역할을 합니다.

## Java 프로그램이 실행되는 여정

### 1단계: 컴파일 과정

먼저 우리가 작성한 `.java` 파일이 **javac 컴파일러**를 통해 `.class` 파일로 변환됩니다. 이때 생성되는 것이 바로 **바이트코드**인데, 이건 사람이 읽기는 어렵지만 JVM이 이해할 수 있는 중간 언어 형태입니다.

### 2단계: 클래스 로딩

JVM이 시작되면 **Class Loader**가 필요한 클래스 파일들을 메모리로 불러옵니다. 이 과정은 세 단계로 나뉘는데, Loading → Linking → Initialization 순서로 진행됩니다. 마치 도서관에서 필요한 책을 찾아서 책상에 올려놓는 것과 비슷하다고 보면 됩니다.

### 3단계: 바이트코드 실행

드디어 **Execution Engine**이 등장할 차례입니다. 여기서는 두 가지 방식으로 바이트코드를 실행할 수 있어요:

**인터프리터 방식**은 바이트코드를 한 줄씩 읽어서 바로바로 실행합니다. 시작은 빠르지만 반복 실행 시에는 좀 느려질 수 있어요.

**JIT 컴파일러 방식**은 자주 사용되는 코드를 미리 기계어로 변환해서 저장해둡니다. 처음엔 시간이 좀 걸리지만, 나중에는 훨씬 빠르게 실행됩니다.

## JVM의 메모리 관리 시스템

JVM이 메모리를 관리하는 방식은 정말 체계적이고 효율적입니다. 각 영역마다 고유한 역할이 있어요.

### Method Area (메서드 영역)

여기는 클래스의 메타데이터가 저장되는 공간입니다. 클래스 정보, 상수 풀, static 변수들이 모여 사는 곳이라고 보면 됩니다. **모든 스레드가 공유**하는 영역이기도 해요.

### Heap 영역 - 객체들의 놀이터

new 키워드로 생성한 객체들이 살고 있는 곳입니다. 이 영역은 다시 **Young Generation**과 **Old Generation**으로 나뉩니다.

**Young Generation**은 새로 태어난 객체들이 머무는 신생아실 같은 곳이에요. Eden, Survivor0, Survivor1 공간으로 세분화되어 있습니다. 대부분의 객체들은 여기서 짧은 생을 마감하죠.

**Old Generation**은 Young Generation에서 살아남은 베테랑 객체들이 이주하는 곳입니다. 오래 살아남을 만한 객체들이 모여있어서 가비지 컬렉션 횟수도 상대적으로 적습니다.

### Stack 영역 - 각자의 작업 공간

각 스레드마다 독립적으로 가지고 있는 영역입니다. 메서드 호출 시 생성되는 지역변수, 매개변수, 리턴 주소 등이 저장됩니다. 메서드가 끝나면 자동으로 정리되는 깔끔한 특성이 있어요.

### PC Register와 Native Method Stack

**PC Register**는 현재 실행 중인 명령어의 주소를 기억하는 작은 공간이고, **Native Method Stack**은 JNI(Java Native Interface)를 통해 호출되는 C/C++ 코드를 위한 별도 스택입니다.

## 가비지 컬렉션 - 자동 청소부

JVM의 가장 큰 장점 중 하나가 바로 **자동 메모리 관리**입니다. 가비지 컬렉터(GC)가 더 이상 사용되지 않는 객체들을 자동으로 찾아서 메모리에서 제거해줍니다.

**Minor GC**는 Young Generation에서 일어나는 가벼운 청소 작업이고, **Major GC**는 Old Generation을 포함한 전체적인 대청소입니다. Major GC가 일어날 때는 잠시 모든 애플리케이션 스레드가 멈추는 "Stop the World" 현상이 발생하기도 해요.

## JVM 성능 튜닝의 핵심

실제 운영 환경에서는 JVM 옵션을 통해 메모리 크기를 조절할 수 있습니다. `-Xms`로 초기 힙 크기를, `-Xmx`로 최대 힙 크기를 설정할 수 있고, `-XX:NewRatio`로 Young과 Old Generation의 비율도 조정 가능합니다.

가비지 컬렉터도 애플리케이션 특성에 맞게 선택할 수 있어요. G1GC, ZGC, Shenandoah 등 다양한 옵션들이 있으니 상황에 맞는 선택이 중요합니다.

JVM은 결국 Java 개발자들이 메모리 관리나 플랫폼별 차이점을 신경 쓰지 않고 비즈니스 로직에만 집중할 수 있게 해주는 고마운 존재입니다. 복잡해 보이지만 한 번 이해하고 나면 Java의 강력함을 더욱 잘 활용할 수 있게 될 거예요.

## 느낀 점
JVM에 대해서는 막연하게만 알고 있었는데 명확히 이해하고 넘어갈 수 있어서 좋았다.
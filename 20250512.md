### charAt()
- 해당 문자열의 특정 인덱스에 해당하는 문자를 반환한다.
- 인덱스는 0부터 시작하는 숫자 체계를 의미하며 인덱스를 벗어난 정수를 인자로 전달하는 경우에는 IndexOutOfBoundsException이 발생한다.

### compareTo()
- 인자로 전달된 문자열과 사전 순으로 비교를 하여 두 문자열이 같다면 0을 반환, 인자로 전달된 문자열보다 작으면 음수를, 크면 양수를 반환한다.
- 단, 이 메소드 대소문자를 구분하여 비교한다.

### concat()
- 문자열에 인자로 전달된 문자열을 합치기해서 새로운 문자열을 반환한다.
- 원본 문자열에는 영향을 주지 않는다.

### indexOf()
- 문자열에서 특정 문자를 탐색하여 처음 일치하는 인덱스 위치를 정수형으로 반환한다.
- 단, 일치하는 문자가 없는 경우 -1을 반환한다.

### lastIndexOf()
- 문자열 탐색을 뒤에서부터 하고 처음 일치하는 위치의 인덱스를 반환한다.
- 단, 일치하는 문자가 없는 경우 -1을 반환한다.

### trim()
- 문자열의 앞 뒤에 공백을 제거한 문자열을 반환한다.
- 원본 문자열에는 영향을 주지 않는다.

### toLowerCase()
- 모든 문자를 소문자로 변환시킨다. 원본에는 영향을 주지 않는다.
### toUpperCase()
- 모든 문자를 대문자로 변환시킨다. 원본에는 영향을 주지 않는다.

### substring()
- 문자열의 일부분을 잘라내어 새로운 문자열을 반환한다. 원본에는 영향을 주지 않는다.

### replace()
- 문자열에서 대체할 문자열로 기존 문자열을 변경해서 반환한다. 원본에는 영향을 주지 않는다.

### length()
- 문자열의 길이를 정수형으로 반환한다.

### isEmpty()
- 문자열의 길이가 0이면 true 반환, 아니면 false를 반환한다. 길이가 0인 문자열은 null과는 다르다.


### 문자열 객체를 만드는 방법
- "" 리터럴 형태 : 동일한 값을 가지는 인스턴스를 단일 인스턴스로 관리한다. (singleton)
- new String("문자열") : 매번 새로운 인스턴스를 생성한다.
- 동일한 문자열은 동일한 hashCode값을 반환하도록 재정의 되어있다.


### equals()
- String 클래스의 equals() 메소드는 인스턴스 비교가 아닌 문자열값을 비교하여 동일한 값을 가지는 경우 true, 다른 값을 가지는 경우 false를 반환하도록 Object의 equals() 메소드를 재정의 해두었다.
- 따라서 문자열 인스턴스 생성 방식과 상관 없이 동일한 문자열인지를 비교하기 위해 == 연산 대신 equals() 메소드를 사용해야 한다.

### 문자열 분리
- 문자열을 특정 구분자로 하여 분리한 문자열을 반환하는 기능을 한다.
  - split() : 정규표현식 이용하여 문자열을 분리한다. 정규표현식을 이용하기 때문에 속도가 느리다는 단점을 가진다.
  - StringTokenizer : 문자열의 모든 문자들을 구분자로 하여 문자열을 구분한다. split()보다 속도면에서 더 빠르다.

### escape 문자
- 문자열 내에서 사용하는 문자 중 특수문자를 표현하거나 특수기능을 사용할 때 사용하는 문자이다.

| 이스케이프 문자 | 의미 |
| :-- | :-- |
| `\n` | 개행(줄바꿈) |
| `\t` | 탭 |
| `\'` | 작은따옴표 |
| `\"` | 큰따옴표 |
| `\\` | 역슬래쉬 표시 |

- split 시 이스케이프 문자를 사용해야 하는 특수문자도 존재한다.
  - 이스케이프 문자 사용 안하는 특수문자
  - ex) ~ ` ! @ # % & - _ = ; : ' \ " ,  < > /
- 이스케이프 문자를 사용하는 특수문자(\\)
  - ex) $ ^ * ( ) + | { } [ ] . ?

### StringBuilder와 StringBuffer
- 두 클래스는 스레드 동기화 기능 제공 여부에 따라 차이점이 있다.
- StringBuilder : 스레드 동기화 기능 제공하지 않음
  - 스레드 동기화처리를 고려하지 않는 상황에서 StringBuffer보다 성능이 좋음 
- StringBuffer : 스레드 동기화 기능 제공 함
  - 성능면에서는 StringBuilder보다 느림

### delete()
- 시작 인덱스와 종료 인덱스를 이용해서 문자열에서 원하는 부분의 문자열을 제거한다. 
- 원본에 영향을 미친다.
### deleteCharAt()
- 문자열 인덱스를 이용해서 문자 하나를 제거한다.
- 원본에 영향을 미친다.

### insert()
- 인자로 전달된 값을 문자열로 변환 후 지정한 인덱스 위치에 추가한다.
- 원본에 영향을 미친다.

### reverse()
- 문자열 인덱스 순번을 역순으로 재배열한다. 
- 원본에 영향을 미친다.

| 기본타입 | 래퍼클래스 |
| :-- | :-- |
| byte | Byte |
| short | Short |
| int | Integer |
| long | Long |
| float | Float |
| double | Double |
| char | Character |
| boolean | Boolean |


### 박싱(Boxing)과 언박싱(UnBoxing)
- 기본타입을 래퍼클래스의 인스턴스로 인스턴스화 하는 것을 박싱(Boxing)이라고 하며,
- 래퍼클래스 타입의 인스턴스를 기본 타입으로 변경하는 것을 언박싱(UnBoxing)이라고 한다.

### parsing
- 문자열(String)값을 기본자료형 값으로 변경하는 것

### valueOf()
- 기본자료형 값을 Wrapper 클래스 타입으로 변환시키는 메소드 
### toString()
- 필드값을 문자열로 반환하는 메소드

### 제네릭
- 사전적인 의미 : 일반적인
- 자바에서 제네릭이란 데이터의 타입을 일반화한다는 의미를 가진다.

- 제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 지정하는 방법을 말한다.
- 컴파일 시에 미리 타입 검사를 시행하게 되면 클래스나 메소드 내부에서 사용되는 사용되는 객체의 타입 안정성을 높일 수 있으며, 반환값에 대한 타입 변환 및 타입 검사에 들어가는 코드 생략이 가능해진다.

#### 제네릭 프로그래밍
- 데이터의 형식에 의존하지 않고 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 두어 재사용성을 높일 수 있는 프로그래밍 방식이다.

### 컬렉션 프레임워크
- 컬렉션 프레임워크는 데이터를 효율적으로 저장하는 자료구조와 데이터를 처리하는 알고리즘을 미리 구현해놓은 클래스이다.

1. List 인터페이스
   - 순서 있는 데이터 집합으로 데이터의 중복 저장을 허용한다.
   - Vector, ArrayList, LinkedList, Stack, Queue 등이 있다.
2. Set 인터페이스
   - 순서가 없는 데이터 집합으로 데이터의 중복을 허용하지 않는다.
   - HashSet, TreeSet 등이 있다.
3. Map 인터페이스
   - 키와 값 한 쌍으로 이루어지는 데이터 집합이다.
   - key를 Set 방식으로 관리하기 때문에 데이터의 순서를 관리하지 않고 중복된 key를 허용하지 않는다.
   - value는 중복된 값을 저장할 수 있다.
   - HashMap, TreeMap, HashTable, Properties 등이 있다.


#### ArrayList
- 가장 많이 사용되는 컬렉션 클래스이다.
- 내부적으로 배열을 이용하여 요소를 관리하며, 인덱스를 이용해 배열 요소에 빠르게 접근할 수 있다.
- rrayList는 배열의 단점을 보완하기 위해 만들어졌다.
- 배열은 크기를 변경할 수 없고, 요소의 추가, 삭제, 정렬 등이 복잡하다는 단점을 가지고 있다.
- ArrayList는 저러한 배열의 단점을 보완하고자 크기 변경, 요소의 추가, 삭제, 정렬 기능들을 미리 메소드로 구현해서 제공하고 있다.
- 자동적으로 수행되는 것이지 속도가 빨라지는 것이 아니다.

### Iterator란?
- Collection 인터페이스의 iterator() 메소드를 이용해서 인스턴스를 생성할 수 있다.
- 컬렉션에서 값을 읽어오는 방식을 통일된 방식으로 제공하기 위해 사용한다.
- 반복자 라고 불리우며, 반복문을 이용해서 목록을 하나씩 꺼내는 방식으로 사용하기 위함이다.
- 인덱스로 관리되는 컬렉션이 아닌 경우에는 반복문을 사용해서 요소에 하나씩 접근할 수 없기 때문에 인덱스를 사용하지 않고도 반복문을 사용하기 위한 목록을 만들어주는 역할이라고 보면 된다.
  - hasNext() : 다음 요소를 가지고 있는 경우 true, 더 이상 요소가 없는 경우 false 반환
  - next() : 다음 요소를 반환

### 느낀 점
- api들을 이용하면 로직을 더 쉽고 빠르게 구현할 수 있겠다는 생각이 들었다. 많이 사용하다보면 저절로 외워지지 않을까 싶다.
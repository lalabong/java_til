# NoSQL

관계형 데이터베이스(RDBMS)가 수십 년간 데이터 저장의 왕좌를 차지하고 있었지만, 웹 2.0과 빅데이터 시대가 오면서 새로운 도전자가 나타났습니다. 바로 **NoSQL(Not Only SQL)** 이죠. 처음에는 "SQL이 아닌" 데이터베이스라는 의미로 받아들여졌지만, 지금은 "SQL만이 아닌" 즉, 더 다양한 방식으로 데이터를 다루는 기술로 이해되고 있어요.

## NoSQL이 등장한 배경과 이유

### 전통적인 RDBMS의 한계

기존 관계형 데이터베이스는 **정형화된 데이터**를 다루는 데는 정말 뛰어났습니다. 은행 시스템, 회계 프로그램, 재고 관리 같은 곳에서는 여전히 최고의 선택이죠. 하지만 SNS, IoT, 실시간 분석 같은 새로운 서비스들이 등장하면서 문제가 생겼어요.

```
전통적인 웹사이트: 하루에 수천 명이 접속
현대적인 SNS 서비스: 초당 수만 명이 동시 접속, 페타바이트급 데이터
```

이런 상황에서 RDBMS는 **수직적 확장(Scale-up)** 이 주된 해결책이었는데, 이는 서버의 성능을 높이는 방식이라서 비용이 기하급수적으로 증가했습니다. "서버가 느려? 그럼 더 비싼 서버를 사자!" 이런 식으로는 페이스북이나 구글 같은 서비스를 감당할 수 없었죠.

### 빅데이터와 다양한 데이터 형태

요즘 데이터는 **정형, 반정형, 비정형**이 뒤섞여 있어요. 사용자가 올린 사진, 동영상, 텍스트, 위치 정보, 클릭 로그... 이런 다양한 데이터를 관계형 테이블에 억지로 맞춰 넣으려니까 복잡하고 비효율적이 되었습니다.

```json
// SNS 포스트 데이터 예시 - 테이블로 표현하기 어려운 구조
{
  "user_id": "john_doe",
  "content": "오늘 날씨가 정말 좋네요!",
  "tags": ["날씨", "일상", "행복"],
  "location": {
    "lat": 37.5665,
    "lng": 126.9780,
    "address": "서울특별시 중구"
  },
  "media": [
    {"type": "image", "url": "photo1.jpg"},
    {"type": "image", "url": "photo2.jpg"}
  ],
  "likes": [],
  "comments": []
}
```


## NoSQL의 핵심 특징과 철학

### 1. 스키마의 유연성 (Schema-less)

NoSQL의 가장 큰 매력 중 하나는 **스키마를 미리 정의하지 않아도 된다**는 점입니다. 관계형 DB에서는 테이블 구조를 먼저 만들어야 하지만, NoSQL에서는 데이터를 넣으면서 구조가 자연스럽게 만들어져요.

```javascript
// MongoDB에서 다양한 구조의 문서를 같은 컬렉션에 저장
db.users.insertMany([
  {
    name: "김개발",
    age: 28,
    skills: ["Java", "Spring", "React"]
  },
  {
    name: "이디자인",
    department: "Design",
    portfolio: "https://portfolio.com",
    tools: {
      design: ["Figma", "Sketch"],
      prototype: ["Framer"]
    }
  }
]);
```


### 2. 수평적 확장성 (Scale-out)

NoSQL은 **여러 서버에 데이터를 분산**해서 저장할 수 있도록 설계되었습니다. 트래픽이 증가하면 서버를 더 추가하면 되는 거죠. 마치 레고 블록처럼 필요한 만큼 조립할 수 있어요.

### 3. CAP 이론과 현실적 타협

분산 시스템에서는 **CAP 이론**이라는 중요한 개념이 있습니다. 일관성(Consistency), 가용성(Availability), 분산 허용성(Partition tolerance) 중에서 최대 2개만 만족할 수 있다는 이론이에요.

```
RDBMS의 선택: 일관성 + 가용성 (CA)
→ 항상 정확한 데이터, 높은 가용성, 하지만 분산이 어려움

NoSQL의 선택: 일관성 + 분산허용성 (CP) 또는 가용성 + 분산허용성 (AP)
→ 분산은 가능하지만 일관성을 어느 정도 포기
```

NoSQL은 **"Eventual Consistency"** 개념을 도입했습니다. 즉, "당장은 최신이 아닐 수 있지만, 결국에는 일관된 상태가 될 것"이라는 타협점을 찾은 거예요.

## NoSQL의 네 가지 주요 타입

### 1. Key-Value Store: 가장 단순하면서도 강력한

**Redis, DynamoDB, Riak**이 대표적인 예시입니다. 마치 프로그래밍의 Map이나 Dictionary 같은 구조예요.

```python
# Redis 사용 예시
import redis

r = redis.Redis()

# 캐싱
r.set("user:1001:profile", json.dumps({"name": "김개발", "level": "Senior"}))
r.expire("user:1001:profile", 3600)  # 1시간 후 만료

# 세션 관리
r.set("session:abc123", "user:1001")

# 실시간 랭킹
r.zadd("leaderboard", {"player1": 1500, "player2": 1200, "player3": 1800})
```

**사용 사례**: 캐싱, 세션 관리, 실시간 랭킹, 장바구니

### 2. Document Store: JSON의 천국

**MongoDB, CouchDB**가 대표적입니다. JSON 문서 형태로 데이터를 저장하는데, 웹 개발자들에게는 정말 친숙한 방식이에요.

```javascript
// MongoDB 사용 예시
// 복잡한 구조의 블로그 포스트 저장
db.posts.insertOne({
  title: "NoSQL 완전 정복하기",
  author: {
    name: "김개발",
    email: "kim@example.com",
    profile: {
      bio: "풀스택 개발자",
      social: {
        github: "kimdev",
        twitter: "@kimdev"
      }
    }
  },
  content: "NoSQL에 대해 알아보자...",
  tags: ["database", "nosql", "mongodb"],
  comments: [
    {
      author: "이리뷰",
      content: "정말 유익한 글이네요!",
      timestamp: new Date(),
      likes: 5
    }
  ],
  metadata: {
    views: 1250,
    likes: 89,
    shares: 12
  }
});

// 복합 쿼리
db.posts.find({
  "tags": "nosql",
  "metadata.views": { $gt: 1000 }
}).sort({ "metadata.likes": -1 });
```

**사용 사례**: CMS, 사용자 프로필, 카탈로그, 실시간 분석

### 3. Column-Family: 빅데이터의 전문가

**Cassandra, HBase**가 대표적입니다. 행이 아닌 열 중심으로 데이터를 저장해서 대용량 데이터 분석에 특화되어 있어요.

```cql
-- Cassandra CQL 예시
CREATE TABLE user_activity (
    user_id UUID,
    activity_date DATE,
    page_views counter,
    session_duration int,
    actions map<text, int>,
    PRIMARY KEY (user_id, activity_date)
);

-- 사용자별 월간 활동 데이터 조회
SELECT * FROM user_activity 
WHERE user_id = 123e4567-e89b-12d3-a456-426614174000 
AND activity_date >= '2025-08-01' 
AND activity_date < '2025-09-01';
```

**사용 사례**: IoT 데이터 수집, 시계열 데이터, 로그 분석, 실시간 분석

### 4. Graph Database: 관계의 예술가

**Neo4j, Amazon Neptune**이 대표적입니다. 소셜 네트워크, 추천 시스템처럼 데이터 간의 관계가 복잡한 경우에 최적화되어 있어요.

```cypher
// Neo4j Cypher 쿼리 예시
// 소셜 네트워크 데이터 모델링
CREATE (김개발:Person {name: '김개발', age: 28, job: 'Developer'})
CREATE (이디자인:Person {name: '이디자인', age: 25, job: 'Designer'})
CREATE (박기획:Person {name: '박기획', age: 30, job: 'PM'})

CREATE (김개발)-[:FOLLOWS]->(이디자인)
CREATE (김개발)-[:WORKS_WITH]->(박기획)
CREATE (이디자인)-[:COLLABORATES_WITH]->(박기획)

// 김개발과 연결된 모든 사람과 그들의 관계 찾기
MATCH (김개발:Person {name: '김개발'})-[r]-(connected)
RETURN 김개발, r, connected;

// 3촌 이내의 추천 친구 찾기
MATCH (김개발:Person {name: '김개발'})-[:FOLLOWS*1..3]-(recommended)
WHERE NOT (김개발)-[:FOLLOWS]-(recommended)
RETURN recommended.name, recommended.job
LIMIT 5;
```

**사용 사례**: 소셜 네트워크, 추천 시스템, 지식 그래프, 사기 탐지

## 실무에서의 NoSQL 선택 가이드

### 언제 NoSQL을 선택해야 할까?

**NoSQL이 좋은 경우**:

- 데이터 구조가 자주 변경되는 스타트업 환경
- 대용량의 읽기 중심 워크로드 (SNS 피드, 뉴스 사이트)
- 실시간 분석이 필요한 서비스
- 지리적으로 분산된 사용자 기반

**RDBMS가 여전히 좋은 경우**:

- 금융 거래처럼 강한 일관성이 필요한 경우
- 복잡한 트랜잭션이 필요한 비즈니스 로직
- 이미 잘 정의된 관계형 구조의 데이터
- 복합적인 분석 쿼리가 필요한 경우


### 하이브리드 접근법

현실적으로는 **폴리글랏 퍼시스턴스(Polyglot Persistence)** 를 많이 사용합니다. 즉, 상황에 맞게 여러 데이터베이스를 조합하는 거죠.

```
실제 서비스 아키텍처 예시:
- 사용자 인증/결제: PostgreSQL (ACID 보장 필요)
- 상품 카탈로그: MongoDB (유연한 스키마)
- 세션/캐시: Redis (빠른 읽기/쓰기)
- 추천 시스템: Neo4j (관계 분석)
- 로그 분석: Elasticsearch (전문 검색)
```


## NoSQL 도입 시 주의사항

### 1. 데이터 일관성 관리

NoSQL의 **Eventual Consistency**는 편리하지만 때로는 함정이 될 수 있어요:

```javascript
// 잘못된 접근: 즉시 일관성을 기대
user.updateProfile({name: "새이름"});
const profile = user.getProfile(); // 아직 업데이트가 반영 안 될 수 있음

// 올바른 접근: 비동기적 처리
user.updateProfile({name: "새이름"}, (err) => {
  if (!err) {
    // 업데이트 완료 후 처리
    const profile = user.getProfile();
  }
});
```


### 2. 쿼리 복잡도와 성능

NoSQL은 복잡한 쿼리가 어려울 수 있어요. 특히 여러 컬렉션/테이블을 조인하는 것은 RDBMS만큼 효율적이지 않습니다.

### 3. 운영과 모니터링

각 NoSQL 데이터베이스마다 운영 방식이 다르기 때문에 학습 비용과 운영 복잡도를 고려해야 합니다.

## 마무리

NoSQL은 이제 "대안 기술"이 아니라 **현대적인 애플리케이션 아키텍처의 핵심 구성요소**가 되었습니다. 클라우드 네이티브, 마이크로서비스, 실시간 분석 같은 현대적 패턴들과 완벽하게 어울리죠.

중요한 건 **"RDBMS를 완전히 대체하는 것"이 아니라 "적재적소에 맞는 도구를 선택하는 것"** 입니다. 망치만 가진 사람에게는 모든 것이 못으로 보인다는 말처럼, 한 가지 데이터베이스만 고집하기보다는 각각의 특성을 이해하고 상황에 맞게 활용하는 것이 현명한 접근법이에요.

앞으로는 **AI/ML과의 연동, 실시간 스트리밍 처리, 엣지 컴퓨팅** 등 새로운 요구사항들이 계속 생길 텐데, NoSQL의 유연성과 확장성이 이런 변화에 대응하는 데 큰 역할을 할 것 같습니다.


# Python 기초와 OpenAI API 연동

## Python 핵심 문법

### 변수와 데이터 타입의 이해

Python에서 변수는 별도의 선언 없이 바로 사용할 수 있어요. 하지만 타입을 의식하면서 코딩하는 습관을 기르는 것이 중요합니다.

```python
# 기본 데이터 타입들
name = "ChatGPT"           # 문자열 (str)
version = 4                # 정수 (int)  
temperature = 0.7          # 실수 (float)
is_available = True        # 불린 (bool)

# 컬렉션 타입들
models = ["gpt-4", "gpt-3.5-turbo"]              # 리스트
user_data = {"name": "김개발", "age": 28}         # 딕셔너리
unique_tags = {"python", "ai", "openai"}         # 셋
coordinates = (37.5665, 126.9780)                # 튜플
```

**문자열 포매팅의 진화**

```python
user = "개발자"
api_calls = 150

# f-string 방식 (권장)
message = f"{user}님이 오늘 {api_calls}번의 API 호출을 하셨습니다."

# 조건문과 함께 사용
status = f"API 상태: {'정상' if api_calls < 1000 else '제한 초과'}"
```


### 조건문과 반복문 활용법

**조건문의 깔끔한 사용**

```python
def check_api_response(status_code):
    if status_code == 200:
        return "성공적으로 처리되었습니다"
    elif status_code == 401:
        return "API 키를 확인해주세요"
    elif status_code == 429:
        return "요청 한도를 초과했습니다"
    else:
        return f"알 수 없는 오류: {status_code}"

# 간단한 조건문
result = "성공" if response.status_code == 200 else "실패"
```

**효율적인 반복문 패턴**

```python
# 딕셔너리 순회 (API 응답 처리할 때 자주 사용)
api_response = {
    "model": "gpt-4",
    "usage": {"total_tokens": 150},
    "choices": [{"message": {"content": "안녕하세요!"}}]
}

for key, value in api_response.items():
    print(f"{key}: {value}")

# enumerate로 인덱스와 함께 순회
messages = ["Hello", "World", "AI"]
for index, message in enumerate(messages):
    print(f"{index}: {message}")

# 리스트 컴프리헨션 (데이터 가공할 때 유용)
user_messages = [msg for msg in conversation if msg["role"] == "user"]
```


### 함수와 클래스 설계

**함수의 현명한 활용**

```python
def create_openai_message(role="user", content="", **kwargs):
    """OpenAI API용 메시지 객체 생성"""
    message = {
        "role": role,
        "content": content
    }
    
    # 추가 매개변수가 있으면 포함
    message.update(kwargs)
    return message

# 사용 예시
user_msg = create_openai_message("user", "Python에 대해 설명해줘")
system_msg = create_openai_message("system", "당신은 친절한 AI 어시스턴트입니다", name="Assistant")
```

**클래스로 OpenAI 클라이언트 만들기**

```python
class OpenAIClient:
    def __init__(self, api_key, model="gpt-3.5-turbo"):
        self.api_key = api_key
        self.model = model
        self.base_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
    
    def chat(self, messages, temperature=0.7):
        """채팅 완성 API 호출"""
        data = {
            "model": self.model,
            "messages": messages,
            "temperature": temperature
        }
        
        response = requests.post(self.base_url, headers=self.headers, json=data)
        response.raise_for_status()
        return response.json()
```


## OpenAI API와 친해지기

### 환경 설정부터 차근차근

API 연동의 첫 걸음은 안전한 환경 설정입니다. API 키를 코드에 직접 노출하는 것은 보안상 위험하니까요.

```python
import requests
import os
from dotenv import load_dotenv

# .env 파일에서 환경변수 로드
load_dotenv()

class APIConfig:
    def __init__(self):
        self.api_key = os.getenv("OPENAI_API_KEY")
        if not self.api_key:
            raise ValueError("OPENAI_API_KEY 환경변수를 설정해주세요")
        
        self.base_url = "https://api.openai.com/v1"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

config = APIConfig()
```

**.env 파일 내용:**

```
OPENAI_API_KEY=sk-your-actual-api-key-here
```


### 기본적인 채팅 완성 API 사용법

가장 많이 사용하는 채팅 완성 API부터 시작해보겠습니다. 실제 서비스에서 사용할 수 있는 형태로 구현해볼게요.

```python
def chat_with_openai(user_message, system_prompt=None, model="gpt-3.5-turbo"):
    """OpenAI와 채팅하는 기본 함수"""
    
    messages = []
    
    # 시스템 프롬프트가 있으면 먼저 추가
    if system_prompt:
        messages.append({"role": "system", "content": system_prompt})
    
    # 사용자 메시지 추가
    messages.append({"role": "user", "content": user_message})
    
    data = {
        "model": model,
        "messages": messages,
        "temperature": 0.7,
        "max_tokens": 1000
    }
    
    try:
        response = requests.post(
            f"{config.base_url}/chat/completions",
            headers=config.headers,
            json=data
        )
        response.raise_for_status()
        
        result = response.json()
        return result["choices"][0]["message"]["content"]
        
    except requests.exceptions.RequestException as e:
        print(f"API 호출 중 오류 발생: {e}")
        return None

# 실제 사용 예시
system_prompt = "당신은 Python 전문가입니다. 초보자도 이해할 수 있게 설명해주세요."
user_question = "f-string이 뭔가요?"

answer = chat_with_openai(user_question, system_prompt)
print(answer)
```


### 대화형 챗봇 만들기

한 번의 질문-답변이 아니라 **연속적인 대화**를 유지하는 챗봇을 만들어보겠습니다.

```python
class ConversationBot:
    def __init__(self, system_prompt="당신은 도움이 되는 AI 어시스턴트입니다."):
        self.messages = [{"role": "system", "content": system_prompt}]
        self.config = APIConfig()
    
    def chat(self, user_input):
        """사용자 입력을 받아 응답 생성"""
        # 사용자 메시지를 대화 히스토리에 추가
        self.messages.append({"role": "user", "content": user_input})
        
        data = {
            "model": "gpt-3.5-turbo",
            "messages": self.messages,
            "temperature": 0.7
        }
        
        try:
            response = requests.post(
                f"{self.config.base_url}/chat/completions",
                headers=self.config.headers,
                json=data
            )
            response.raise_for_status()
            
            result = response.json()
            ai_response = result["choices"][0]["message"]["content"]
            
            # AI 응답도 대화 히스토리에 추가
            self.messages.append({"role": "assistant", "content": ai_response})
            
            return ai_response
            
        except Exception as e:
            return f"죄송합니다. 오류가 발생했습니다: {e}"
    
    def reset_conversation(self):
        """대화 히스토리 초기화 (시스템 메시지는 유지)"""
        self.messages = self.messages[:1]  # 첫 번째 시스템 메시지만 남김

# 사용 예시
bot = ConversationBot("당신은 Python과 AI에 특화된 전문 어시스턴트입니다.")

print("AI 챗봇과 대화를 시작합니다. 'quit'을 입력하면 종료됩니다.")
while True:
    user_input = input("\n사용자: ")
    if user_input.lower() == 'quit':
        break
    
    response = bot.chat(user_input)
    print(f"AI: {response}")
```


### 실전 활용: 텍스트 분석 도구

OpenAI API를 활용해서 실제로 유용한 텍스트 분석 도구를 만들어보겠습니다.

```python
class TextAnalyzer:
    def __init__(self):
        self.config = APIConfig()
    
    def _call_api(self, messages):
        """공통 API 호출 메서드"""
        data = {
            "model": "gpt-3.5-turbo",
            "messages": messages,
            "temperature": 0.3  # 분석 작업이므로 낮은 temperature 사용
        }
        
        response = requests.post(
            f"{self.config.base_url}/chat/completions",
            headers=self.config.headers,
            json=data
        )
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"]
    
    def summarize(self, text):
        """텍스트 요약"""
        messages = [
            {"role": "system", "content": "주어진 텍스트를 3-5문장으로 요약해주세요."},
            {"role": "user", "content": f"다음 텍스트를 요약해주세요:\n\n{text}"}
        ]
        return self._call_api(messages)
    
    def analyze_sentiment(self, text):
        """감정 분석"""
        messages = [
            {"role": "system", "content": "텍스트의 감정을 분석하여 긍정, 부정, 중립 중 하나로 판단하고 그 이유를 설명해주세요."},
            {"role": "user", "content": text}
        ]
        return self._call_api(messages)
    
    def extract_keywords(self, text):
        """키워드 추출"""
        messages = [
            {"role": "system", "content": "텍스트에서 중요한 키워드 10개를 추출하여 쉼표로 구분하여 나열해주세요."},
            {"role": "user", "content": text}
        ]
        return self._call_api(messages)

# 실사용 예시
analyzer = TextAnalyzer()

sample_text = """
인공지능 기술의 발전으로 우리의 일상생활이 크게 변화하고 있습니다. 
ChatGPT와 같은 대화형 AI는 교육, 업무, 창작 등 다양한 분야에서 활용되고 있으며, 
앞으로 더욱 혁신적인 변화를 가져올 것으로 예상됩니다.
"""

print("=== 텍스트 분석 결과 ===")
print(f"요약: {analyzer.summarize(sample_text)}")
print(f"감정 분석: {analyzer.analyze_sentiment(sample_text)}")
print(f"키워드: {analyzer.extract_keywords(sample_text)}")
```


## 실무에서 알아두면 좋은 팁들

### 오류 처리와 안정성

API 호출은 네트워크 문제나 서비스 장애로 인해 실패할 수 있어요. 안전한 코드를 위해서는 적절한 예외 처리가 필수입니다.

```python
import time
from functools import wraps

def retry_on_failure(max_retries=3, delay=1):
    """실패 시 재시도하는 데코레이터"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except requests.exceptions.RequestException as e:
                    if attempt == max_retries - 1:  # 마지막 시도
                        raise e
                    print(f"시도 {attempt + 1} 실패. {delay}초 후 재시도...")
                    time.sleep(delay)
            return None
        return wrapper
    return decorator

@retry_on_failure(max_retries=3, delay=2)
def safe_api_call(messages):
    """안전한 API 호출"""
    response = requests.post(
        f"{config.base_url}/chat/completions",
        headers=config.headers,
        json={"model": "gpt-3.5-turbo", "messages": messages}
    )
    response.raise_for_status()
    return response.json()
```


### 비용 최적화 전략

OpenAI API는 토큰 단위로 과금되므로 효율적인 사용이 중요합니다.

```python
def estimate_tokens(text):
    """대략적인 토큰 수 추정 (정확하지 않지만 참고용)"""
    return len(text.split()) * 1.3  # 영어 기준 근사치

def optimize_prompt(user_input, max_tokens=1000):
    """프롬프트 길이 최적화"""
    estimated = estimate_tokens(user_input)
    
    if estimated > max_tokens:
        # 텍스트가 너무 길면 잘라내기
        words = user_input.split()
        target_words = int(max_tokens / 1.3)
        user_input = " ".join(words[:target_words]) + "..."
        print(f"입력이 너무 길어 {target_words}단어로 제한했습니다.")
    
    return user_input
```

## 느낀 점
파이썬은 아니지만 LLM은 처음 사용해보는데 어떻게 해야 효율적이고 좋은 코드가 나올지 더 고민해봐야겠다.


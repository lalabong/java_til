
# RabbitMQ

분산 시스템을 구축하다 보면 서로 다른 애플리케이션들이 어떻게 안전하고 효율적으로 소통할지 고민하게 됩니다. 직접 API를 호출하는 방법도 있지만, 이는 강한 결합을 만들어 시스템을 경직되게 만들죠. **RabbitMQ**는 이런 문제를 해결해주는 메시지 브로커입니다. 마치 우체국처럼 메시지를 안전하게 중계해주는 역할을 하는 거예요.

## RabbitMQ가 해결하는 근본적인 문제

### 동기 처리의 한계

기존 시스템에서는 A 서비스가 B 서비스를 직접 호출하는 방식이 일반적이었습니다. 하지만 이런 **동기적 통신**에는 여러 문제가 있어요:

```
문제 상황:
- B 서비스가 다운되면 A 서비스도 영향을 받음
- B 서비스 응답이 느리면 A 서비스도 같이 느려짐
- 트래픽이 몰리면 B 서비스가 과부하
- 시스템 간 강한 결합으로 확장성 제한
```


### 비동기 메시징의 우아한 해결책

RabbitMQ는 **AMQP(Advanced Message Queuing Protocol)** 를 구현한 메시지 브로커로, 이런 문제들을 **비동기 메시징**으로 해결합니다. 서비스들이 서로 직접 대화하는 대신, 메시지를 우체국(RabbitMQ)에 맡기고 받는 방식이죠.

```
RabbitMQ 방식:
- A 서비스가 메시지를 RabbitMQ에 전송
- RabbitMQ가 메시지를 안전하게 저장
- B 서비스가 준비될 때 메시지를 가져가서 처리
- 서비스 간 직접적인 의존성 제거
```


## RabbitMQ의 핵심 구성요소

### Producer와 Consumer: 메시지의 시작과 끝

**Producer(생산자)** 는 메시지를 생성해서 RabbitMQ로 보내는 애플리케이션입니다. 주의할 점은 Producer가 Consumer에게 직접 메시지를 보내는 게 아니라, 항상 RabbitMQ 브로커를 통해서 전달한다는 거예요.

**Consumer(소비자)** 는 RabbitMQ에서 메시지를 가져와서 실제 비즈니스 로직을 처리하는 애플리케이션입니다. 여러 Consumer가 동시에 연결되어 작업을 분산 처리할 수도 있어요.

```java
// Spring Boot에서 Producer 예시
@Component
public class OrderMessageProducer {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void sendOrderCreated(OrderEvent orderEvent) {
        rabbitTemplate.convertAndSend(
            "order.exchange",           // Exchange 이름
            "order.created",            // Routing Key
            orderEvent                  // 메시지 내용
        );
        
        log.info("주문 생성 이벤트 발송: {}", orderEvent.getOrderId());
    }
}

// Consumer 예시
@Component
public class OrderMessageConsumer {
    
    @RabbitListener(queues = "order.processing.queue")
    public void handleOrderCreated(OrderEvent orderEvent) {
        log.info("주문 처리 시작: {}", orderEvent.getOrderId());
        
        // 실제 비즈니스 로직 처리
        orderProcessingService.processOrder(orderEvent);
        
        log.info("주문 처리 완료: {}", orderEvent.getOrderId());
    }
}
```


### Queue: 메시지가 머무는 대기실

**Queue(큐)** 는 메시지가 Consumer에게 전달되기 전까지 임시로 저장되는 공간입니다. FIFO(First In, First Out) 구조로 동작하며, 메시지가 안전하게 보관되어 서비스가 다운되어도 메시지가 손실되지 않아요.

```yaml
# Queue 설정 예시
spring:
  rabbitmq:
    queues:
      order-processing:
        name: order.processing.queue
        durable: true          # 서버 재시작 시에도 큐 유지
        auto-delete: false     # Consumer가 없어도 큐 삭제 안 함
        arguments:
          x-message-ttl: 300000    # 메시지 생존 시간 5분
          x-max-length: 10000      # 최대 메시지 개수
```


### Exchange: 똑똑한 메시지 분배자

**Exchange(교환기)** 는 RabbitMQ의 가장 핵심적인 개념입니다. Producer가 보낸 메시지를 어떤 Queue로 전달할지 결정하는 라우터 역할을 해요. Exchange는 네 가지 타입이 있습니다:

**1. Direct Exchange: 정확한 매칭**

```java
// 라우팅 키가 정확히 일치하는 큐로만 전달
@RabbitListener(queues = "user.signup.queue")
public void handleUserSignup(UserEvent event) {
    // user.signup 라우팅 키로 온 메시지만 처리
}

@RabbitListener(queues = "user.login.queue") 
public void handleUserLogin(UserEvent event) {
    // user.login 라우팅 키로 온 메시지만 처리
}
```

**2. Topic Exchange: 패턴 매칭**

```java
// 와일드카드를 사용한 유연한 라우팅
@RabbitListener(queues = "order.all.queue")
@RabbitListener(bindings = @QueueBinding(
    value = @Queue("order.all.queue"),
    exchange = @Exchange(value = "order.topic.exchange", type = "topic"),
    key = "order.*"  // order.created, order.updated, order.deleted 모두 받음
))
public void handleAllOrderEvents(OrderEvent event) {
    // order로 시작하는 모든 이벤트 처리
}
```

**3. Fanout Exchange: 브로드캐스트**

```java
// 모든 연결된 큐로 메시지 복사 전달
@Component
public class NotificationProducer {
    
    public void sendGlobalNotification(String message) {
        rabbitTemplate.convertAndSend(
            "notification.fanout.exchange",  // Fanout Exchange
            "",                              // 라우팅 키 무시됨
            message
        );
    }
}

// 여러 Consumer가 모두 같은 메시지를 받음
@RabbitListener(queues = "email.notification.queue")
public void sendEmail(String message) { /* 이메일 발송 */ }

@RabbitListener(queues = "sms.notification.queue") 
public void sendSMS(String message) { /* SMS 발송 */ }

@RabbitListener(queues = "push.notification.queue")
public void sendPush(String message) { /* 푸시 알림 발송 */ }
```

**4. Headers Exchange: 메타데이터 기반**

```java
// 메시지 헤더 값을 기준으로 라우팅 (실무에서는 잘 안 씀)
Map<String, Object> headers = new HashMap<>();
headers.put("priority", "high"); 
headers.put("type", "urgent");

rabbitTemplate.convertAndSend("headers.exchange", "", message, msg -> {
    msg.getMessageProperties().getHeaders().putAll(headers);
    return msg;
});
```


## 실무에서의 RabbitMQ 활용 패턴

### 이벤트 기반 아키텍처

마이크로서비스에서 가장 일반적인 패턴이 **이벤트 기반 아키텍처**입니다. 한 서비스에서 발생한 이벤트를 다른 서비스들이 구독해서 처리하는 방식이에요.

```java
// 주문 서비스에서 이벤트 발행
@Service
public class OrderService {
    
    @Autowired
    private OrderEventPublisher eventPublisher;
    
    @Transactional
    public Order createOrder(CreateOrderRequest request) {
        // 주문 생성
        Order order = orderRepository.save(new Order(request));
        
        // 이벤트 발행
        eventPublisher.publishOrderCreated(OrderCreatedEvent.from(order));
        
        return order;
    }
}

// 재고 서비스에서 주문 이벤트 구독
@Component
public class InventoryEventHandler {
    
    @RabbitListener(queues = "inventory.order.queue")
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 재고 차감 처리
        inventoryService.decreaseStock(event.getItems());
    }
}

// 알림 서비스에서 주문 이벤트 구독
@Component  
public class NotificationEventHandler {
    
    @RabbitListener(queues = "notification.order.queue")
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 주문 확인 이메일 발송
        emailService.sendOrderConfirmation(event.getUserEmail(), event);
    }
}
```


### 작업 큐 패턴

시간이 오래 걸리는 작업을 백그라운드에서 처리할 때 RabbitMQ를 활용합니다.

```java
// 이미지 처리 작업 큐
@Component
public class ImageProcessingProducer {
    
    public void requestImageProcessing(String imageUrl, String userId) {
        ImageProcessingTask task = ImageProcessingTask.builder()
            .imageUrl(imageUrl)
            .userId(userId)
            .requestedAt(LocalDateTime.now())
            .build();
            
        rabbitTemplate.convertAndSend(
            "image.processing.queue", 
            task
        );
    }
}

// 여러 Worker가 동시에 작업 처리
@Component
public class ImageProcessingWorker {
    
    @RabbitListener(
        queues = "image.processing.queue",
        concurrency = "3-10"  // 동시 처리 Worker 수
    )
    public void processImage(ImageProcessingTask task) {
        try {
            // 이미지 리사이징, 워터마크 추가 등
            ProcessedImage result = imageService.processImage(task.getImageUrl());
            
            // 처리 완료 알림
            notificationService.notifyProcessingComplete(task.getUserId(), result);
            
        } catch (Exception e) {
            log.error("이미지 처리 실패: {}", task, e);
            // DLX(Dead Letter Exchange)로 실패한 작업 전송
            throw e;
        }
    }
}
```


### 서킷 브레이커와 재시도 패턴

RabbitMQ는 메시지 처리 실패 시 자동 재시도와 Dead Letter Exchange 기능을 제공합니다.

```java
@Configuration
public class RabbitMQConfig {
    
    @Bean
    public Queue mainQueue() {
        return QueueBuilder.durable("payment.processing.queue")
            .withArgument("x-dead-letter-exchange", "payment.dlx.exchange")
            .withArgument("x-dead-letter-routing-key", "payment.failed")
            .withArgument("x-message-ttl", 300000)  // 5분 TTL
            .build();
    }
    
    @Bean
    public Queue deadLetterQueue() {
        return QueueBuilder.durable("payment.failed.queue").build();
    }
}

@Component
public class PaymentProcessor {
    
    @RabbitListener(queues = "payment.processing.queue")
    @Retryable(value = {PaymentException.class}, maxAttempts = 3)
    public void processPayment(PaymentRequest request) {
        try {
            paymentService.processPayment(request);
        } catch (PaymentException e) {
            log.warn("결제 처리 실패, 재시도 중: {}", request.getOrderId());
            throw e;  // 재시도 트리거
        }
    }
    
    @RabbitListener(queues = "payment.failed.queue")
    public void handleFailedPayment(PaymentRequest request) {
        // 실패한 결제 처리 - 관리자 알림, 보상 트랜잭션 등
        adminNotificationService.notifyPaymentFailure(request);
    }
}
```


## RabbitMQ vs 다른 메시지 브로커

### RabbitMQ vs Apache Kafka

두 도구는 서로 다른 용도에 최적화되어 있어요:

```
RabbitMQ:
- 복잡한 라우팅 규칙이 필요한 경우
- 메시지 순서보다 안정성과 유연성이 중요한 경우
- 실시간 처리보다 신뢰성 있는 메시지 전달이 우선
- 마이크로서비스 간 이벤트 기반 통신

Kafka:
- 대용량 데이터 스트리밍 처리
- 메시지 순서가 중요한 경우
- 높은 처리량이 필요한 로그 수집, 실시간 분석
- 이벤트 소싱, 데이터 파이프라인
```


### Redis vs RabbitMQ

```
Redis (Pub/Sub):
- 단순한 발행/구독 패턴
- 메시지 영속성 보장 안 됨
- 매우 빠른 속도
- 실시간 알림, 캐시 무효화

RabbitMQ:
- 복잡한 라우팅과 메시지 보장
- 메시지 영속성과 안정성
- 풍부한 기능 (DLX, TTL, 우선순위 등)
- 신뢰성 있는 비즈니스 로직 처리
```


## 운영 환경에서의 고려사항

### 클러스터링과 고가용성

```yaml
# RabbitMQ 클러스터 설정 (Docker Compose)
version: '3.8'
services:
  rabbitmq-1:
    image: rabbitmq:3-management
    hostname: rabbit-1
    environment:
      RABBITMQ_ERLANG_COOKIE: "secret-cookie"
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: password
    volumes:
      - ./cluster-entrypoint.sh:/usr/local/bin/cluster-entrypoint.sh
    command: cluster-entrypoint.sh
    
  rabbitmq-2:
    image: rabbitmq:3-management  
    hostname: rabbit-2
    depends_on:
      - rabbitmq-1
    environment:
      RABBITMQ_ERLANG_COOKIE: "secret-cookie"
    command: >
      bash -c "
        rabbitmq-server -detached &&
        rabbitmqctl stop_app &&
        rabbitmqctl join_cluster rabbit@rabbit-1 &&
        rabbitmqctl start_app &&
        tail -f /dev/null
      "
```


### 모니터링과 관리

RabbitMQ Management UI를 통해 실시간 모니터링이 가능합니다:

```bash
# Management 플러그인 활성화
rabbitmq-plugins enable rabbitmq_management

# 웹 UI 접속: http://localhost:15672
# 기본 계정: guest/guest (로컬에서만 접속 가능)
```

실무에서는 Prometheus + Grafana 조합으로 메트릭을 수집하는 것이 일반적입니다.

## 마무리

RabbitMQ는 단순한 메시지 전달 도구를 넘어서, **탄력적이고 확장 가능한 분산 시스템의 핵심 구성요소**가 되었습니다. 마이크로서비스, 이벤트 기반 아키텍처, 클라우드 네이티브 개발에서 거의 필수적인 도구로 자리잡았어요.

특히 요즘처럼 시스템이 복잡해지고 실시간 처리 요구사항이 늘어나는 환경에서, RabbitMQ의 **유연한 라우팅, 안정적인 메시지 보장, 다양한 통합 옵션**은 개발자들에게 정말 든든한 무기가 됩니다.

처음에는 복잡해 보일 수 있지만, 기본 개념부터 차근차근 익히고 실제 프로젝트에 적용해보면 "메시지 큐 없이 어떻게 분산 시스템을 만들었을까?" 싶을 정도로 강력함을 느끼게 될 거예요. 시스템 간의 결합을 느슨하게 만들면서도 안정성과 확장성을 모두 확보할 수 있는 RabbitMQ, 정말 매력적인 기술입니다.

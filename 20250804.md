
# 자바의 클래스, 객체, 인스턴스: 개념부터 실무까지

자바를 처음 배울 때 가장 헷갈리는 개념이 바로 클래스, 객체, 인스턴스입니다. 이 세 개념은 서로 밀접하게 연관되어 있지만 각각 다른 의미를 가지고 있어요. 실제 개발에서 어떻게 사용되는지 예시와 함께 알아보겠습니다.

## 클래스: 객체를 만들기 위한 설계도

클래스는 **객체를 만들기 위한 템플릿이나 설계도**라고 생각하면 됩니다. 마치 붕어빵을 만들 때 사용하는 틀과 같죠. 틀 자체는 붕어빵이 아니지만, 이 틀을 사용해서 실제 붕어빵을 만들 수 있습니다.

```java
public class User {
    // 속성 (멤버 변수)
    private String name;
    private String email;
    private int age;
    
    // 생성자
    public User(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
    
    // 행동 (메서드)
    public void sendEmail(String message) {
        System.out.println(name + "에게 이메일 발송: " + message);
    }
    
    public boolean isAdult() {
        return age >= 18;
    }
    
    // getter와 setter는 생략...
}
```

여기서 `User` 클래스는 사용자라는 개념을 코드로 표현한 설계도입니다. 실제 사용자가 아니라 사용자가 어떤 속성을 가져야 하고 어떤 행동을 할 수 있는지를 정의한 것이죠.

## 객체: 클래스로부터 만들어진 실체

객체는 **클래스라는 설계도를 바탕으로 실제로 만들어진 실체**입니다. 붕어빵 틀로 만든 실제 붕어빵과 같다고 보면 됩니다. 하나의 클래스로 여러 개의 서로 다른 객체를 만들 수 있어요.

```java
public class UserExample {
    public static void main(String[] args) {
        // User 클래스로부터 객체들을 생성
        User user1 = new User("김개발", "kim@example.com", 25);
        User user2 = new User("이자바", "lee@example.com", 30);
        User user3 = new User("박스프링", "park@example.com", 17);
        
        // 각 객체는 독립적인 상태를 가짐
        user1.sendEmail("안녕하세요!");
        user2.sendEmail("회의 시간 변경 안내");
        
        System.out.println(user1.isAdult()); // true
        System.out.println(user3.isAdult()); // false
    }
}
```

`user1`, `user2`, `user3`는 모두 `User` 클래스로부터 만들어진 서로 다른 객체입니다. 같은 설계도로 만들어졌지만 각각 다른 이름, 이메일, 나이를 가지고 있죠.

## 인스턴스: 메모리에 실제로 할당된 객체

인스턴스는 **객체가 메모리에 실제로 할당되어 사용 가능한 상태**를 의미합니다. 사실 객체와 인스턴스는 거의 같은 의미로 사용되는 경우가 많은데, 조금 더 정확히 구분하자면:

**객체**는 개념적인 용어이고, **인스턴스**는 메모리 관점에서의 용어라고 볼 수 있습니다.

```java
User user = new User("홍길동", "hong@example.com", 28);
// user는 User 클래스의 인스턴스를 참조하는 변수
// 메모리 어딘가에 실제 User 객체가 생성되어 있음
```

Spring Boot에서 실제로 사용하는 예를 들어보면:

```java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private int price;
    private String category;
    
    // 생성자, getter, setter 등...
}

@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public Product createProduct(ProductCreateRequest request) {
        // Product 클래스로부터 새로운 인스턴스 생성
        Product product = Product.builder()
            .name(request.getName())
            .price(request.getPrice())
            .category(request.getCategory())
            .build();
            
        // 데이터베이스에 저장하면 실제 메모리와 DB에 인스턴스가 존재
        return productRepository.save(product);
    }
}
```


## 실무에서의 활용 패턴

실제 개발할 때는 이 개념들이 어떻게 사용되는지 알아보겠습니다.

**DTO(Data Transfer Object) 패턴에서:**

```java
// 클래스 정의
public class UserResponseDto {
    private Long id;
    private String name;
    private String email;
    
    public static UserResponseDto from(User user) {
        return UserResponseDto.builder()
            .id(user.getId())
            .name(user.getName())
            .email(user.getEmail())
            .build();
    }
}

// Controller에서 사용
@RestController
public class UserController {
    
    @GetMapping("/users/{id}")
    public ResponseEntity<UserResponseDto> getUser(@PathVariable Long id) {
        User user = userService.getUser(id); // User 인스턴스
        UserResponseDto response = UserResponseDto.from(user); // DTO 인스턴스
        return ResponseEntity.ok(response);
    }
}
```

**팩토리 패턴에서:**

```java
// 클래스 정의
public class PaymentProcessorFactory {
    
    public static PaymentProcessor createProcessor(PaymentType type) {
        switch (type) {
            case CREDIT_CARD:
                return new CreditCardProcessor(); // 인스턴스 생성
            case KAKAO_PAY:
                return new KakaoPayProcessor();   // 인스턴스 생성
            default:
                throw new IllegalArgumentException("지원하지 않는 결제 타입입니다.");
        }
    }
}
```


## 메모리 관점에서 이해하기

클래스, 객체, 인스턴스를 메모리 관점에서 보면 더 명확해집니다:

```java
User user1 = new User("김개발", "kim@example.com", 25);
User user2 = new User("이자바", "lee@example.com", 30);
User user3 = user1; // 같은 인스턴스를 참조
```

**메모리 상태:**

```
[Method Area]
- User 클래스 정보 (메서드, 필드 정의 등)

[Heap Memory]
- 인스턴스 #1: {"김개발", "kim@example.com", 25}
- 인스턴스 #2: {"이자바", "lee@example.com", 30}

[Stack Memory]
- user1 변수 → 인스턴스 #1 주소 참조
- user2 변수 → 인스턴스 #2 주소 참조  
- user3 변수 → 인스턴스 #1 주소 참조 (user1과 동일)
```

이래서 `user1`과 `user3`는 같은 인스턴스를 참조하므로 한쪽에서 값을 변경하면 다른 쪽에서도 변경된 값을 볼 수 있습니다.

## 가비지 컬렉션과의 관계

자바에서는 더 이상 참조되지 않는 인스턴스들이 자동으로 메모리에서 제거됩니다:

```java
public void demonstrateGarbageCollection() {
    User user = new User("임시사용자", "temp@example.com", 20);
    // user 인스턴스가 메모리에 생성됨
    
    user = null; // 참조를 끊음
    // 이제 해당 인스턴스는 가비지 컬렉션 대상이 됨
    
    // 또는 메서드가 끝나면 지역변수 user도 사라져서
    // 자동으로 가비지 컬렉션 대상이 됨
}
```


## 마무리

**클래스**는 객체를 만들기 위한 설계도이고, **객체**는 그 설계도로 만든 실체이며, **인스턴스**는 메모리에 실제로 할당된 그 객체를 가리킵니다.

실무에서는 이 구분을 엄격하게 나누기보다는, "User 클래스의 인스턴스를 생성한다" 또는 "새로운 User 객체를 만든다"는 식으로 자연스럽게 사용합니다. 중요한 것은 각 개념이 무엇을 의미하는지 이해하고, 메모리에서 어떻게 동작하는지 아는 것입니다.

이 개념들을 제대로 이해하면 Spring Boot에서 Bean 생성, JPA Entity 관리, 디자인 패턴 적용 등이 훨씬 쉬워집니다.


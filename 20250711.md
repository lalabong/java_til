## JPA (Java Persistence API)란?
- JPA는 자바 진영의 ORM(Object-Relational Mapping) 기술 표준 명세이다.
- 즉, JPA는 실제 구현이 아닌 인터페이스의 모음이며, 데이터베이스와 객체 지향 프로그래밍 언어 간의 패러다임 불일치를 해결하기 위한 방법을 정의한다.
- 따라서 개발자는 SQL을 직접 작성하는 대신 자바 객체를 통해 데이터베이스를 조작할 수 있다.

### Spring data JPA란?
- JPA를 더 쉽고 편하게 사용하도록 스프링 프레임워크에서 제공하는 모듈
- Repository 인터페이스를 제공하여 데이터 접근 계층을 간단하게 구현할 수 있도록 돕는다.

### 영속성 컨텍스트
- 영속성 컨텍스트는 엔티티를 영구 저장하는 환경으로, JPA의 핵심 개념 중 하나이다.
- EntityManager를 통해 엔티티를 저장하거나 조회하면, 해당 엔티티는 영속성 컨텍스트에 의해 관리된다.

#### 영속성 컨텍스트의 이점

- 1차 캐시: 영속성 컨텍스트 내부에는 캐시가 존재하며, 같은 트랜잭션 내에서 같은 엔티티를 조회할 경우 데이터베이스를 거치지 않고 캐시에서 바로 가져온다. 이는 성능 향상과 엔티티의 동일성을 보장하는 데 도움이 된다.

- 쓰기 지연 (Transactional Write-Behind): INSERT, UPDATE, DELETE 등의 SQL을 바로 데이터베이스에 보내지 않고 트랜잭션 커밋 시점까지 SQL 저장소에 모아둔다. 그리고 트랜잭션이 커밋될 때 모아둔 쿼리를 한 번에 데이터베이스로 보낸다.

- 변경 감지 (Dirty Checking): 트랜잭션이 커밋될 때, 1차 캐시에 저장된 엔티티의 최초 상태(스냅샷)와 현재 상태를 비교합니다. 만약 변경 사항이 감지되면 UPDATE SQL을 자동으로 생성하여 데이터베이스에 반영한다. 이 덕분에 개발자는 update 메서드를 명시적으로 호출할 필요가 없다.

- 지연 로딩 (Lazy Loading): 연관된 엔티티를 실제 사용하는 시점까지 조회를 미루는 기능

#### 즉시 로딩(Eager Loading)과 지연 로딩(Lazy Loading)의 차이점은?
- 즉시 로딩 (FetchType.EAGER): 엔티티를 조회할 때 연관된 모든 엔티티를 함께 조회하는 방식. @ManyToOne, @OneToOne 관계의 기본값

- 지연 로딩 (FetchType.LAZY): 연관된 엔티티를 실제 사용하는 시점에 조회하는 방식. @OneToMany, @ManyToMany 관계의 기본값

#### N+1문제란?
- 특정 엔티티를 조회(1번의 쿼리)한 후, 해당 엔티티와 연관된 다른 엔티티들을 지연 로딩으로 가져올 때, 연관된 엔티티의 수(N)만큼 추가적인 쿼리가 발생하는 현상
- 해결방안
  - Fetch Join: JPQL을 사용하여 조회 시점에 연관된 엔티티를 함께 가져오는 방법

  - @EntityGraph: JPQL을 수정하지 않고도 어노테이션을 통해 함께 조회할 필드를 명시할 수 있다.

  - 배치 사이즈 (Batch Size): @BatchSize 어노테이션이나 hibernate.default_batch_fetch_size 설정을 통해 지정된 개수만큼의 연관 엔티티를 IN절을 사용하여 한 번에 조회

## 느낀 점
- JPA가 무엇인지는 면접장에서 확실히 말할 수 있어야 하겠다.
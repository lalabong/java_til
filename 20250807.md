# 오버로딩 vs 오버라이딩: 비슷해 보이지만 완전히 다른 두 개념

Java를 배우면서 가장 헷갈리는 개념 중 하나가 바로 오버로딩(Overloading)과 오버라이딩(Overriding)입니다. 둘 다 "Over"로 시작해서 비슷해 보이지만, 실제로는 완전히 다른 목적과 동작 방식을 가지고 있어요. 실무에서 Spring Boot 개발을 하다 보면 이 두 개념을 자연스럽게 사용하게 되는데, 그 차이를 명확히 이해하면 훨씬 더 깔끔한 코드를 작성할 수 있습니다.

## 핵심 차이: 같은 이름, 다른 철학

**오버로딩**은 **같은 클래스 안에서 같은 이름의 메서드를 여러 개 만드는 것**이고, **오버라이딩**은 **부모 클래스의 메서드를 자식 클래스에서 새롭게 정의하는 것**입니다.

쉽게 말해, 오버로딩은 "하나의 기능을 다양한 방법으로 사용할 수 있게 하자"이고, 오버라이딩은 "부모가 정의한 기능을 내 스타일로 바꿔보자"라는 철학입니다.

## 오버로딩: 편의성의 마법사

오버로딩은 같은 이름의 메서드를 **매개변수의 개수나 타입을 다르게 해서** 여러 개 정의하는 것입니다. 사용자 입장에서는 하나의 메서드명만 기억하면 되니까 정말 편리하죠.

```java
public class UserService {
    
    // 기본 사용자 생성
    public User createUser(String name) {
        return new User(name, null, 0);
    }
    
    // 이메일을 포함한 사용자 생성
    public User createUser(String name, String email) {
        return new User(name, email, 0);
    }
    
    // 모든 정보를 포함한 사용자 생성
    public User createUser(String name, String email, int age) {
        return new User(name, email, age);
    }
    
    // 사용자 정보 객체로 생성
    public User createUser(UserCreateRequest request) {
        return new User(request.getName(), request.getEmail(), request.getAge());
    }
}
```

실제 사용할 때는 상황에 맞게 적절한 버전을 선택할 수 있어요:

```java
@RestController
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/users/simple")
    public ResponseEntity<User> createSimpleUser(@RequestBody String name) {
        User user = userService.createUser(name); // 1개 매개변수 버전
        return ResponseEntity.ok(user);
    }
    
    @PostMapping("/users/full")
    public ResponseEntity<User> createFullUser(@RequestBody UserCreateRequest request) {
        User user = userService.createUser(request); // 객체 매개변수 버전
        return ResponseEntity.ok(user);
    }
}
```

Java 표준 라이브러리에서도 오버로딩을 정말 많이 사용합니다. `System.out.println()`이 대표적인 예시죠:

```java
System.out.println("문자열");      // String 버전
System.out.println(123);          // int 버전  
System.out.println(true);         // boolean 버전
System.out.println(3.14);         // double 버전
```


## 오버라이딩: 개성의 표현

오버라이딩은 상속 관계에서 **부모 클래스의 메서드를 자식 클래스에서 재정의**하는 것입니다. 같은 메서드명과 시그니처를 유지하면서도 구현 내용을 바꿀 수 있어요.

```java
// 부모 클래스
public abstract class PaymentProcessor {
    
    // 모든 결제 처리기가 구현해야 하는 메서드
    public abstract PaymentResult process(PaymentRequest request);
    
    // 공통 로직
    public void logPayment(PaymentRequest request) {
        System.out.println("결제 요청: " + request.getAmount() + "원");
    }
}

// 신용카드 결제 처리기
public class CreditCardProcessor extends PaymentProcessor {
    
    @Override  // 오버라이딩 표시
    public PaymentResult process(PaymentRequest request) {
        // 신용카드만의 결제 로직
        validateCreditCard(request.getCardNumber());
        chargeCard(request.getAmount());
        
        return PaymentResult.builder()
            .success(true)
            .message("신용카드 결제 완료")
            .transactionId(generateTransactionId())
            .build();
    }
    
    private void validateCreditCard(String cardNumber) { /* 신용카드 검증 */ }
    private void chargeCard(double amount) { /* 카드 결제 */ }
}

// 카카오페이 결제 처리기
public class KakaoPayProcessor extends PaymentProcessor {
    
    @Override
    public PaymentResult process(PaymentRequest request) {
        // 카카오페이만의 결제 로직
        String kakaoToken = authenticateKakaoPay(request.getUserId());
        processKakaoPayment(kakaoToken, request.getAmount());
        
        return PaymentResult.builder()
            .success(true)
            .message("카카오페이 결제 완료")
            .transactionId(generateKakaoTransactionId())
            .build();
    }
    
    private String authenticateKakaoPay(String userId) { /* 카카오 인증 */ return "token"; }
    private void processKakaoPayment(String token, double amount) { /* 카카오페이 결제 */ }
}
```

이렇게 오버라이딩을 사용하면 **다형성**의 힘을 발휘할 수 있습니다:

```java
@Service
public class PaymentService {
    
    public PaymentResult processPayment(PaymentProcessor processor, PaymentRequest request) {
        processor.logPayment(request); // 부모 클래스의 공통 로직
        
        // 실제 구현체에 따라 다른 process 메서드가 호출됨 (다형성!)
        return processor.process(request);
    }
}

// 사용 예시
PaymentProcessor creditCard = new CreditCardProcessor();
PaymentProcessor kakaoPay = new KakaoPayProcessor();

paymentService.processPayment(creditCard, request); // 신용카드 로직 실행
paymentService.processPayment(kakaoPay, request);   // 카카오페이 로직 실행
```


## 실무에서의 활용: Spring Boot 맥락에서

### 오버로딩 활용 사례

Spring Boot에서 Repository나 Service 메서드를 만들 때 오버로딩을 자주 사용합니다:

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 이메일로 사용자 찾기
    Optional<User> findByEmail(String email);
    
    // 이름으로 사용자 찾기  
    List<User> findByName(String name);
    
    // 이름과 나이로 사용자 찾기
    List<User> findByNameAndAge(String name, int age);
    
    // 나이 범위로 사용자 찾기
    List<User> findByAgeBetween(int minAge, int maxAge);
}

@Service
public class UserSearchService {
    
    @Autowired
    private UserRepository userRepository;
    
    // 다양한 검색 방법을 제공 (오버로딩)
    public List<User> searchUsers(String email) {
        return userRepository.findByEmail(email)
            .map(List::of)
            .orElse(Collections.emptyList());
    }
    
    public List<User> searchUsers(String name, int age) {
        return userRepository.findByNameAndAge(name, age);
    }
    
    public List<User> searchUsers(int minAge, int maxAge) {
        return userRepository.findByAgeBetween(minAge, maxAge);
    }
}
```


### 오버라이딩 활용 사례

Spring Boot의 설정이나 인터페이스 구현에서 오버라이딩을 많이 사용합니다:

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    // WebMvcConfigurer의 메서드를 오버라이딩
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("http://localhost:3000")
            .allowedMethods("GET", "POST", "PUT", "DELETE");
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new AuthInterceptor())
            .addPathPatterns("/api/admin/**");
    }
}

// Custom Exception Handler
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException e) {
        // 특정 예외에 대한 커스텀 처리 (오버라이딩의 개념)
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(ErrorResponse.of("사용자를 찾을 수 없습니다.", e.getMessage()));
    }
}
```


## 헷갈리기 쉬운 포인트들

### 매개변수의 이름은 중요하지 않다

오버로딩에서는 매개변수의 **타입과 개수**만 중요하고, 이름은 상관없습니다:

```java
// 이건 오버로딩이 아닙니다! (컴파일 에러)
public void createUser(String name) { }
public void createUser(String email) { } // 매개변수 타입과 개수가 동일

// 이건 올바른 오버로딩입니다
public void createUser(String name) { }
public void createUser(String name, String email) { } // 매개변수 개수가 다름
```


### 오버라이딩은 @Override 어노테이션을 쓰자

```java
public class CustomService extends BaseService {
    
    @Override // 이 어노테이션을 반드시 쓰세요!
    public void processData() {
        // 부모 메서드 재정의
        super.processData(); // 부모 로직도 실행하고 싶다면
        // 추가 로직
    }
}
```

`@Override` 어노테이션을 쓰면 컴파일러가 실제로 부모 메서드를 올바르게 재정의했는지 검증해줍니다. 오타가 있으면 컴파일 에러가 나서 실수를 방지할 수 있어요.

### 접근 제한자 규칙

오버라이딩할 때는 부모 메서드보다 **접근 권한을 넓힐 수는 있지만 좁힐 수는 없습니다**:

```java
public class Parent {
    protected void doSomething() { } // protected
}

public class Child extends Parent {
    @Override
    public void doSomething() { }    // OK: protected → public (권한 확대)
    
    // @Override
    // private void doSomething() { } // 컴파일 에러: protected → private (권한 축소)
}
```


## 현실적인 사용 가이드

**오버로딩을 사용하는 경우:**

- 같은 기능을 다양한 매개변수로 제공하고 싶을 때
- API의 편의성을 높이고 싶을 때
- 생성자나 팩토리 메서드를 만들 때

**오버라이딩을 사용하는 경우:**

- 부모 클래스의 동작을 자식 클래스에 맞게 변경하고 싶을 때
- 추상 메서드를 구체적으로 구현할 때
- 인터페이스의 메서드를 구현할 때
- 기존 라이브러리의 동작을 커스터마이즈할 때


## 마무리

오버로딩과 오버라이딩은 각각 다른 문제를 해결하는 도구입니다. 오버로딩은 **사용 편의성**을 위한 것이고, 오버라이딩은 **다형성과 확장성**을 위한 것이죠.

Spring Boot 개발을 하다 보면 Repository 메서드를 다양하게 만들 때는 오버로딩을, 인터페이스를 구현하거나 기존 기능을 확장할 때는 오버라이딩을 자연스럽게 사용하게 됩니다.

중요한 건 각각의 목적을 이해하고, 상황에 맞게 적절히 사용하는 것입니다. 그러면 더 깔끔하고 유지보수하기 쉬운 코드를 작성할 수 있어요.


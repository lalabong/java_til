# Java 배열 vs 연결리스트: 데이터 저장 방식의 근본적 차이

데이터 구조를 처음 배울 때 가장 기본이 되는 배열과 연결리스트. 둘 다 여러 개의 데이터를 저장한다는 점에서는 같지만, 메모리에서 데이터를 관리하는 방식이 완전히 다릅니다. 실무에서 ArrayList를 쓸지 LinkedList를 쓸지 고민해본 적이 있다면, 이 차이를 이해하는 게 정말 중요해요.

## 메모리 구조: 아파트 vs 단독주택의 차이

배열과 연결리스트의 가장 큰 차이는 **메모리에서 데이터가 저장되는 방식**입니다.

### 배열: 연속된 메모리 공간

배열은 메모리에서 **연속된 공간**에 데이터를 저장합니다. 마치 아파트처럼 101호, 102호, 103호가 나란히 붙어있는 것과 같죠.

```java
int[] numbers = {10, 20, 30, 40, 50};

// 메모리 상태 (예시)
// [주소 1000] 10
// [주소 1004] 20  ← 바로 다음 위치 (int는 4바이트)
// [주소 1008] 30
// [주소 1012] 40
// [주소 1016] 50
```

이 구조 덕분에 배열은 **인덱스를 통한 직접 접근**이 가능합니다. `numbers`를 호출하면 시작 주소 + (2 × 4바이트) = 1008번지로 바로 점프할 수 있어요.

### 연결리스트: 흩어진 메모리 공간

연결리스트는 데이터가 **메모리 곳곳에 흩어져 저장**되고, 각 노드가 다음 노드의 주소를 가지고 있습니다. 단독주택들이 여기저기 떨어져 있고, 각 집에 다음 집 주소가 적힌 쪽지가 있다고 생각하면 됩니다.

```java
// LinkedList의 내부 구조 (간소화된 버전)
class Node {
    int data;
    Node next;
    
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

// 메모리 상태 (예시)
// [주소 2000] {data: 10, next: 3500}
// [주소 3500] {data: 20, next: 1200}  ← 물리적으로 떨어져 있음
// [주소 1200] {data: 30, next: 4800}
// [주소 4800] {data: 40, next: null}
```


## 접근 방식: 직통 엘리베이터 vs 계단 오르기

이런 메모리 구조 차이 때문에 데이터에 접근하는 방식도 완전히 달라집니다.

### 배열: O(1) 랜덤 액세스

배열은 인덱스만 알면 **한 번에 바로 접근**할 수 있습니다.

```java
int[] scores = new int[1000];
// 몇 번째 요소든 똑같이 빠르게 접근
int firstScore = scores[0];     // 빠름
int middleScore = scores[500];  // 똑같이 빠름
int lastScore = scores[999];    // 여전히 빠름
```


### 연결리스트: O(n) 순차 접근

연결리스트는 원하는 위치까지 **처음부터 차례대로** 따라가야 합니다.

```java
LinkedList<Integer> list = new LinkedList<>();
// 1000개 요소가 있다면...
int firstElement = list.get(0);    // 빠름 (바로 접근)
int middleElement = list.get(500); // 느림 (500번 링크 따라가야 함)
int lastElement = list.get(999);   // 매우 느림 (999번 링크 따라가야 함)
```

실제로 Spring Boot에서 대용량 데이터 처리할 때 이 차이를 체감할 수 있어요:

```java
@Service
public class DataProcessingService {
    
    // 배열 기반 (ArrayList) - 빠른 조회
    public String processWithArrayList(List<String> data, int index) {
        return data.get(index).toUpperCase(); // O(1) - 매우 빠름
    }
    
    // 연결리스트 기반 - 느린 조회
    public String processWithLinkedList(LinkedList<String> data, int index) {
        return data.get(index).toUpperCase(); // O(n) - 인덱스가 클수록 느림
    }
}
```


## 삽입과 삭제: 각자의 강점이 다르다

### 배열: 중간 삽입/삭제가 비싸다

배열에서 중간에 요소를 삽입하거나 삭제하려면 뒤의 모든 요소를 이동시켜야 합니다.

```java
ArrayList<String> names = new ArrayList<>(Arrays.asList("김", "이", "박", "최"));

// 중간에 "정" 삽입 - 뒤의 요소들이 모두 한 칸씩 밀려남
names.add(1, "정");  // ["김", "정", "이", "박", "최"]
// 내부적으로: "이", "박", "최"를 모두 오른쪽으로 이동

// 중간 요소 삭제 - 뒤의 요소들이 모두 한 칸씩 당겨짐  
names.remove(2);     // ["김", "정", "박", "최"]
// 내부적으로: "박", "최"를 모두 왼쪽으로 이동
```


### 연결리스트: 중간 삽입/삭제가 효율적

연결리스트는 링크만 조정하면 되므로 삽입/삭제가 빠릅니다.

```java
LinkedList<String> names = new LinkedList<>(Arrays.asList("김", "이", "박", "최"));

// 중간에 삽입 - 링크만 조정
names.add(1, "정");  // 단순히 포인터만 조정하면 됨

// 중간 삭제 - 링크만 조정
names.remove(2);     // 해당 노드를 연결에서 제외하고 메모리 해제
```


## 실무에서의 선택 기준

실제 개발할 때 언제 어떤 것을 써야 할지 알아보겠습니다.

### ArrayList를 선택하는 경우

**조회가 많고 삽입/삭제가 적은 경우**에 ArrayList가 유리합니다.

```java
@RestController
public class ProductController {
    
    // 상품 목록 조회 - 인덱스 기반 접근이 빈번
    @GetMapping("/products")
    public ResponseEntity<List<ProductDto>> getProducts() {
        List<Product> products = productRepository.findAll(); // ArrayList 반환
        
        // 페이징 처리 - 특정 인덱스 접근이 많음
        List<ProductDto> result = products.stream()
            .skip(page * size)                    // 인덱스 기반 접근
            .limit(size)
            .map(ProductDto::from)
            .collect(Collectors.toList());        // ArrayList로 수집
            
        return ResponseEntity.ok(result);
    }
}
```


### LinkedList를 선택하는 경우

**중간 삽입/삭제가 빈번하고 순차 접근이 주인 경우**에 LinkedList가 유리합니다.

```java
@Component
public class MessageQueue {
    private LinkedList<Message> messageQueue = new LinkedList<>();
    
    // 큐의 앞쪽에 긴급 메시지 삽입
    public void addUrgentMessage(Message message) {
        messageQueue.addFirst(message);  // O(1) - 매우 빠름
    }
    
    // 큐의 뒤쪽에 일반 메시지 추가
    public void addMessage(Message message) {
        messageQueue.addLast(message);   // O(1) - 매우 빠름
    }
    
    // 메시지 처리 (순차 접근)
    public void processMessages() {
        while (!messageQueue.isEmpty()) {
            Message msg = messageQueue.removeFirst(); // O(1) - 매우 빠름
            processMessage(msg);
        }
    }
}
```


## 메모리 사용량: 숨겨진 비용

### 배열: 순수한 데이터만

배열은 실제 데이터만 저장하므로 메모리 사용량이 효율적입니다.

```java
int[] numbers = new int[1000];
// 메모리 사용량: 1000 × 4바이트 = 4KB (순수 데이터만)
```


### 연결리스트: 추가 포인터 비용

연결리스트는 각 노드마다 다음 노드를 가리키는 포인터가 추가로 필요합니다.

```java
LinkedList<Integer> numbers = new LinkedList<>();
// 1000개 요소 저장 시:
// 데이터: 1000 × 4바이트 = 4KB
// 포인터: 1000 × 8바이트 = 8KB (64비트 시스템 기준)
// 총 메모리 사용량: 12KB (3배!)
```

실제 Spring Boot 애플리케이션에서 대량 데이터를 다룰 때 이 차이가 누적되면 상당한 메모리 오버헤드가 됩니다.

## 캐시 효율성: 성능의 숨은 요소

현대 CPU는 **캐시 메모리**를 사용해서 성능을 향상시킵니다. 배열은 메모리에 연속으로 저장되어 있어서 캐시 히트율이 높지만, 연결리스트는 데이터가 흩어져 있어서 캐시 미스가 자주 발생합니다.

```java
// 배열 순회 - 캐시 친화적
int[] arr = new int[1000000];
int sum = 0;
for (int i = 0; i < arr.length; i++) {
    sum += arr[i];  // 연속된 메모리 접근으로 캐시 효율 높음
}

// 연결리스트 순회 - 캐시 비친화적  
LinkedList<Integer> list = new LinkedList<>();
int sum2 = 0;
for (Integer value : list) {
    sum2 += value;  // 흩어진 메모리 접근으로 캐시 미스 빈발
}
```


## 현실적인 선택 가이드

실무에서는 다음과 같은 기준으로 선택하면 됩니다:

**ArrayList를 사용하세요** (90% 이상의 경우):

- 일반적인 CRUD 작업
- 데이터 조회가 빈번한 경우
- 성능이 중요한 경우
- 메모리 효율성이 중요한 경우

**LinkedList를 사용하세요** (특수한 경우):

- 큐(Queue)나 스택(Stack) 구현
- 중간 삽입/삭제가 매우 빈번한 경우
- 데이터 크기를 예측할 수 없는 경우

```java
// 일반적인 경우 - ArrayList 사용
List<User> users = new ArrayList<>();  // 추천

// 큐 구현이 필요한 경우 - LinkedList 사용
Queue<Task> taskQueue = new LinkedList<>();  // 적절한 선택
```


## 마무리

배열과 연결리스트는 각각의 장단점이 명확합니다. 배열은 빠른 접근과 메모리 효율성을, 연결리스트는 유연한 삽입/삭제를 제공합니다.

실무에서는 대부분 ArrayList를 사용하게 되지만, 특정 상황에서는 LinkedList가 더 적합할 수 있어요. 중요한 건 각자의 특성을 이해하고, 요구사항에 맞는 도구를 선택하는 것입니다.

Spring Boot 개발을 하다 보면 JPA에서 반환하는 List나 Stream API를 사용할 때 이런 차이를 자연스럽게 체감하게 됩니다. 그때 이 개념들을 떠올려보면 더 나은 코드를 작성할 수 있을 거예요.


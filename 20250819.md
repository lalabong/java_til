# SSE

웹 개발을 하다 보면 "서버에서 뭔가 변화가 있을 때 브라우저가 알아서 업데이트됐으면 좋겠다"는 생각을 한 번쯤 해봤을 거예요. 주식 가격이 바뀌거나, 새로운 알림이 왔거나, 채팅 메시지가 도착했을 때 사용자가 새로고침을 누르지 않아도 자동으로 화면이 업데이트되는 것 말이죠. **SSE(Server-Sent Events)** 는 바로 이런 요구사항을 간단하게 해결해주는 기술입니다.

## SSE가 해결하는 문제

전통적인 웹 통신은 **요청-응답 패턴**이 기본이에요. 클라이언트가 서버에게 "뭔가 새로운 게 있어?"라고 물어봐야 서버가 답해주는 구조죠. 실시간 업데이트가 필요한 서비스에서는 이게 정말 비효율적입니다.

### 기존 방식의 문제점들

**폴링(Polling) 방식**의 경우 클라이언트가 주기적으로 서버에 요청을 보내야 해요. 예를 들어 5초마다 "새로운 메시지 있어?"라고 물어보는 거죠. 하지만 대부분의 요청은 "없어"라는 답변만 받게 되니까 네트워크 자원과 서버 자원이 엄청나게 낭비됩니다.

**Long Polling**은 조금 나아지지만 여전히 복잡하고, 서버 리소스를 오래 점유하는 문제가 있어요.

### SSE의 우아한 해결책

SSE는 이런 문제를 **"서버가 필요할 때 클라이언트에게 직접 말을 건다"** 는 방식으로 해결합니다. 마치 친구가 카톡으로 먼저 연락을 주는 것처럼, 서버에서 변화가 생기면 연결된 모든 클라이언트에게 실시간으로 알려주는 거예요.

## SSE의 핵심 특징들

### 단방향 통신의 명확함
SSE는 **서버에서 클라이언트로만 데이터를 보내는 단방향 통신**입니다. 이게 한계처럼 보일 수 있지만, 실제로는 많은 실시간 기능들이 단방향이면 충분해요. 주식 시세, 뉴스 피드, 알림, 진행 상태 등은 모두 서버에서 클라이언트로만 정보를 보내면 되거든요.

```javascript
// 클라이언트에서 SSE 연결 생성
const eventSource = new EventSource('/api/notifications');

eventSource.onmessage = function(event) {
    const data = JSON.parse(event.data);
    console.log('새로운 알림:', data.message);
    // UI 업데이트 로직
};
```


### HTTP 기반의 안전함

SSE는 **일반적인 HTTP 프로토콜을 기반**으로 동작합니다. 이게 정말 큰 장점이에요. 방화벽이나 프록시 서버, 로드 밸런서 등 기존 웹 인프라와 완벽하게 호환되거든요. WebSocket처럼 별도의 프로토콜 업그레이드가 필요하지 않아서 네트워크 환경에서 문제가 생길 확률이 훨씬 적어요.

### 자동 재연결의 편리함

SSE의 또 다른 강점은 **자동 재연결 기능**입니다. 네트워크가 일시적으로 끊어져도 `EventSource` 객체가 알아서 재연결을 시도해요. 개발자가 별도로 복잡한 재연결 로직을 구현할 필요가 없죠.

## 실제 구현해보기

### Spring Boot에서 SSE 구현

Spring Boot에서 SSE를 구현하는 건 정말 간단합니다:

```java
@RestController
@RequestMapping("/api/sse")
public class SseController {
    
    private final Map<String, SseEmitter> emitters = new ConcurrentHashMap<>();
    
    @GetMapping(value = "/connect", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter connect(@RequestParam String userId) {
        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
        
        // 연결 관리
        emitter.onCompletion(() -> emitters.remove(userId));
        emitter.onTimeout(() -> emitters.remove(userId));
        emitter.onError((ex) -> emitters.remove(userId));
        
        emitters.put(userId, emitter);
        
        try {
            // 연결 확인 메시지 전송
            emitter.send(SseEmitter.event()
                .name("connect")
                .data("연결되었습니다"));
        } catch (IOException e) {
            emitters.remove(userId);
        }
        
        return emitter;
    }
    
    @PostMapping("/notify")
    public ResponseEntity<String> sendNotification(
            @RequestParam String userId, 
            @RequestParam String message) {
        
        SseEmitter emitter = emitters.get(userId);
        if (emitter != null) {
            try {
                emitter.send(SseEmitter.event()
                    .name("notification")
                    .data(message));
                return ResponseEntity.ok("알림 전송 완료");
            } catch (IOException e) {
                emitters.remove(userId);
                return ResponseEntity.status(500).body("전송 실패");
            }
        }
        return ResponseEntity.notFound().build();
    }
}
```


### 프론트엔드에서 SSE 활용

React나 Vue.js에서 SSE를 사용하는 것도 직관적입니다:

```javascript
// React Hook 예시
import { useState, useEffect } from 'react';

function useSSE(url) {
    const [messages, setMessages] = useState([]);
    const [connectionStatus, setConnectionStatus] = useState('connecting');
    
    useEffect(() => {
        const eventSource = new EventSource(url);
        
        eventSource.onopen = () => {
            setConnectionStatus('connected');
        };
        
        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            setMessages(prev => [...prev, data]);
        };
        
        eventSource.onerror = () => {
            setConnectionStatus('error');
        };
        
        return () => {
            eventSource.close();
        };
    }, [url]);
    
    return { messages, connectionStatus };
}

// 컴포넌트에서 사용
function NotificationComponent() {
    const { messages, connectionStatus } = useSSE('/api/sse/connect?userId=123');
    
    return (
        <div>
            <div>연결 상태: {connectionStatus}</div>
            {messages.map((msg, index) => (
                <div key={index}>{msg}</div>
            ))}
        </div>
    );
}
```


## SSE의 실용적인 활용 사례들

### AI 채팅과 스트리밍 응답

요즘 ChatGPT 같은 AI 서비스에서 답변이 실시간으로 타이핑되는 것처럼 나오는 걸 본 적 있을 거예요. 이게 바로 SSE를 활용한 대표적인 사례입니다. 사용자가 질문을 하면 AI가 답변을 생성하면서 동시에 부분적으로 결과를 전송하는 거죠.

```java
@PostMapping("/chat")
public SseEmitter streamChat(@RequestBody ChatRequest request) {
    SseEmitter emitter = new SseEmitter();
    
    // AI 서비스로부터 스트리밍 응답 받기
    aiService.generateResponse(request.getMessage(), (chunk) -> {
        try {
            emitter.send(SseEmitter.event()
                .name("chunk")
                .data(chunk));
        } catch (IOException e) {
            emitter.completeWithError(e);
        }
    });
    
    return emitter;
}
```


### 실시간 모니터링 대시보드

시스템 모니터링, 주식 차트, 실시간 매출 현황 같은 대시보드에서 SSE는 정말 유용합니다. 사용자가 페이지를 열어두기만 하면 최신 데이터가 자동으로 업데이트되거든요.

### 진행 상황 표시

파일 업로드, 데이터 처리, 배치 작업 등의 진행 상황을 실시간으로 보여주는 프로그레스 바에도 SSE가 완벽합니다. 서버에서 작업 진행률을 계산해서 클라이언트로 보내주면 되니까요.

## SSE vs WebSocket: 언제 무엇을 선택할까?

### SSE를 선택해야 하는 경우

**단방향 통신이면 충분한 상황**에서는 SSE가 더 나은 선택입니다. 구현이 간단하고, HTTP 기반이라 안정적이며, 자동 재연결까지 지원하거든요. 알림 시스템, 실시간 피드, 모니터링 대시보드, AI 스트리밍 응답 등이 대표적인 사용 사례예요.

### WebSocket을 고려해야 하는 경우

**양방향 실시간 통신**이 필요한 경우에는 WebSocket이 적합합니다. 실시간 채팅, 멀티플레이어 게임, 협업 도구 등에서는 클라이언트에서 서버로도 실시간으로 데이터를 보내야 하니까요.

## 실무에서의 주의사항

### 연결 관리의 중요성

SSE를 운영 환경에서 사용할 때는 **연결 관리**가 정말 중요해요. 사용자가 페이지를 닫아도 서버에서는 연결이 끊어진 걸 바로 알기 어렵거든요. 메모리 누수를 방지하기 위해서는 적절한 타임아웃과 정리 로직이 필요합니다

```java
// 연결 정리를 위한 스케줄링
@Scheduled(fixedRate = 30000) // 30초마다 실행
public void cleanupConnections() {
    emitters.entrySet().removeIf(entry -> {
        try {
            // 연결 상태 확인용 핑 전송
            entry.getValue().send(SseEmitter.event().name("ping").data(""));
            return false;
        } catch (IOException e) {
            // 연결이 끊어진 경우 제거
            return true;
        }
    });
}
```


### 확장성 고려사항

사용자가 많아지면 서버에서 유지해야 하는 연결의 수도 늘어납니다. 이때는 Redis 같은 외부 저장소를 활용해서 여러 서버 인스턴스 간에 연결 정보를 공유하거나, 메시지 브로커를 통해 이벤트를 분산 처리하는 방법을 고려해야 해요.

## 마무리

SSE는 복잡한 실시간 통신 문제를 **단순하고 우아하게 해결**해주는 기술입니다. WebSocket만큼 화려하지는 않지만, 많은 실무 상황에서는 SSE만으로도 충분하고 오히려 더 안정적인 경우가 많아요.

특히 요즘처럼 사용자 경험이 중요한 시대에, 페이지 새로고침 없이도 최신 정보를 제공하는 것은 거의 필수적인 기능이 되었습니다. SSE는 이런 요구사항을 **최소한의 복잡성으로 최대한의 효과**를 낼 수 있게 해주는 정말 실용적인 기술이에요.

다음에 실시간 기능을 구현해야 하는 상황이 생기면, 복잡한 WebSocket부터 고민하지 말고 SSE로도 충분한지 먼저 검토해보세요. 아마 생각보다 많은 경우에서 SSE가 완벽한 해답이 될 거예요.

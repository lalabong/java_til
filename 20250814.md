
# Prometheus와 Grafana: 시스템 모니터링의 완벽한 조합

서버를 운영하다 보면 "지금 시스템이 어떤 상태인지" 알고 싶은 순간이 많아요. CPU 사용률이 얼마나 되는지, 메모리는 충분한지, 애플리케이션에 에러가 발생하고 있는지... 이런 궁금증을 해결해주는 게 바로 **Prometheus와 Grafana**입니다. 둘이 만나면 정말 강력한 모니터링 시스템이 완성되거든요.

## Prometheus: 메트릭 수집의 신뢰할 수 있는 파트너

**Prometheus는 시계열 데이터 수집과 저장에 특화된 오픈소스 모니터링 시스템**입니다. SoundCloud에서 개발되어 지금은 CNCF의 졸업 프로젝트가 된, 정말 검증된 도구예요

### Prometheus의 핵심 동작 원리

가장 특징적인 건 **Pull 방식**으로 데이터를 수집한다는 점입니다. 다른 모니터링 시스템들이 각 서버에서 중앙으로 데이터를 밀어 넣는(Push) 방식을 쓴다면, Prometheus는 반대로 중앙에서 각 서버의 메트릭을 주기적으로 가져와요.

```yaml
# prometheus.yml 설정 예시
global:
  scrape_interval: 30s  # 30초마다 메트릭 수집

scrape_configs:
  - job_name: 'web-servers'
    static_configs:
      - targets: ['localhost:8080', 'server1:8080', 'server2:8080']
  
  - job_name: 'database-servers'
    static_configs:
      - targets: ['db1:9100', 'db2:9100']
```

이런 식으로 설정하면 Prometheus가 알아서 각 서버에서 메트릭을 주기적으로 가져와서 자신의 시계열 데이터베이스에 저장합니다.

### 강력한 쿼리 언어 PromQL

Prometheus가 정말 강력한 이유 중 하나는 **PromQL**이라는 전용 쿼리 언어를 제공한다는 점이에요. SQL처럼 복잡한 조건으로 메트릭을 조회하고 분석할 수 있습니다.

```promql
# CPU 사용률이 80% 이상인 서버 찾기
100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[5m])) by (instance) * 100) > 80

# 지난 1시간 동안 HTTP 요청이 가장 많은 서비스
topk(5, sum(rate(http_requests_total[1h])) by (service))

# 메모리 사용률 계산
(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100
```


### Spring Boot와의 연동

실무에서 가장 많이 사용하는 패턴 중 하나가 Spring Boot 애플리케이션과 Prometheus 연동이에요. Spring Actuator와 Micrometer를 사용하면 정말 쉽게 메트릭을 노출할 수 있습니다.

```java
// Spring Boot에서 Prometheus 메트릭 노출
@RestController
public class MetricsController {
    
    private final MeterRegistry meterRegistry;
    
    @GetMapping("/api/users")
    public ResponseEntity<List<User>> getUsers() {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            List<User> users = userService.getAllUsers();
            meterRegistry.counter("api.users.success").increment();
            return ResponseEntity.ok(users);
        } catch (Exception e) {
            meterRegistry.counter("api.users.error").increment();
            throw e;
        } finally {
            sample.stop(Timer.builder("api.users.duration").register(meterRegistry));
        }
    }
}
```


## Grafana: 데이터를 아름다운 시각으로 만드는 마법사

**Grafana는 수집된 메트릭을 시각적으로 표현하는 강력한 대시보드 툴**입니다. Prometheus와 완벽하게 연동되어 복잡한 시계열 데이터를 이해하기 쉬운 그래프와 차트로 변환해줘요.

### 다양한 데이터 소스 지원

Grafana의 큰 장점 중 하나는 **Prometheus뿐만 아니라 다양한 데이터 소스를 지원**한다는 점입니다. MySQL, PostgreSQL, Elasticsearch, InfluxDB 등 거의 모든 데이터베이스와 연동할 수 있어서 통합 모니터링이 가능해요.

```json
// Grafana 대시보드 패널 설정 예시
{
  "targets": [
    {
      "expr": "rate(http_requests_total[5m])",
      "legendFormat": "{{method}} {{status}}",
      "refId": "A"
    }
  ],
  "title": "HTTP Request Rate",
  "type": "graph"
}
```


### 실시간 모니터링과 알람

Grafana는 단순한 시각화를 넘어서 **실시간 알람 기능**도 제공합니다. 특정 임계값을 넘으면 이메일, Slack, PagerDuty 등으로 알람을 보낼 수 있어요.

```yaml
# Grafana 알람 규칙 예시
alerting:
  rules:
    - alert: HighCPUUsage
      expr: node_cpu_usage > 0.8
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High CPU usage detected"
        description: "CPU usage is above 80% for more than 5 minutes"
```


## 실제 구축하기: Docker로 간단한 모니터링 스택

Prometheus와 Grafana를 실제로 구축하는 건 생각보다 간단해요. Docker Compose를 사용하면 몇 분 만에 완전한 모니터링 환경을 만들 수 있습니다.

```yaml
# docker-compose.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3000:3000"
    volumes:
      - grafana_data:/var/lib/grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123

  node-exporter:
    image: prom/node-exporter:latest
    container_name: node-exporter
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'

volumes:
  prometheus_data:
  grafana_data:
```


## 실무에서의 활용 패턴

### 애플리케이션 성능 모니터링

Spring Boot 애플리케이션의 핵심 지표들을 모니터링하는 대시보드 구성:

```promql
# API 응답 시간 모니터링
histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))

# 데이터베이스 연결 풀 상태
hikaricp_connections_active / hikaricp_connections_max * 100

# JVM 메모리 사용률
jvm_memory_used_bytes / jvm_memory_max_bytes * 100

# 에러 발생률
rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m]) * 100
```


### 인프라 모니터링

서버 인프라의 핵심 지표들:

```promql
# CPU 사용률
100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)

# 메모리 사용률
(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100

# 디스크 사용률
(1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100

# 네트워크 트래픽
rate(node_network_receive_bytes_total[5m]) * 8
```


## 고급 활용: 성능 최적화와 스케일링

### Recording Rules로 쿼리 최적화

복잡한 쿼리를 미리 계산해두는 Recording Rules:

```yaml
# recording_rules.yml
groups:
  - name: performance_rules
    interval: 30s
    rules:
      - record: instance:node_cpu_utilization:rate5m
        expr: 100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[5m])) by (instance) * 100)
      
      - record: service:http_request_rate:rate5m
        expr: sum(rate(http_requests_total[5m])) by (service)
```


### 분산 환경에서의 Prometheus

대규모 환경에서는 **Prometheus Federation**이나 **Thanos**를 활용해서 여러 Prometheus 인스턴스를 연동할 수 있어요.

## 주의사항과 모범 사례

### 메트릭 설계 원칙

좋은 메트릭을 설계하는 것이 성공적인 모니터링의 핵심입니다:

- **카디널리티 주의**: 라벨의 값이 너무 많으면 메모리 사용량이 급증
- **의미 있는 메트릭**: 비즈니스 로직과 연관된 지표 추가
- **적절한 수집 주기**: 너무 자주 수집하면 오버헤드, 너무 드물면 놓치는 이벤트 발생


### 알람 피로도 방지

**의미 있는 알람만 설정**하는 것이 중요해요. 너무 많은 알람은 오히려 중요한 문제를 놓치게 만듭니다.

```yaml
# 좋은 알람 규칙 예시
- alert: ServiceDown
  expr: up == 0
  for: 1m
  labels:
    severity: critical
  annotations:
    summary: "Service {{ $labels.instance }} is down"

- alert: HighErrorRate
  expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
  for: 2m
  labels:
    severity: warning
```


## 마무리: 모니터링의 진화

Prometheus와 Grafana는 단순한 모니터링 도구를 넘어서, **데이터 기반 의사결정을 가능하게 하는 플랫폼**이 되었습니다. 시스템의 현재 상태를 파악하는 것뿐만 아니라, 트렌드 분석, 용량 계획, 성능 최적화까지 가능하게 해주죠.

특히 클라우드 네이티브와 마이크로서비스 환경에서는 거의 필수적인 도구가 되었어요. Kubernetes와의 완벽한 통합, 다양한 Exporter 생태계, 그리고 활발한 커뮤니티 덕분에 앞으로도 계속 발전할 것 같습니다.

결국 좋은 모니터링 시스템은 **문제가 발생하기 전에 미리 알려주고, 문제가 발생했을 때 빠르게 원인을 파악할 수 있게 해주는 것**이 핵심이에요. Prometheus와 Grafana는 바로 그런 환경을 만들어주는 최고의 조합입니다.



# AWS 배포 과정: 로컬에서 클라우드까지의 여정

개발한 애플리케이션을 실제 사용자가 접속할 수 있는 환경으로 옮기는 과정, 바로 배포입니다. AWS는 이 과정을 다양한 방법으로 지원하는데, 처음에는 복잡해 보이지만 한 번 익숙해지면 정말 강력한 도구가 되어줍니다. 실제 현업에서 많이 사용되는 배포 패턴들을 중심으로 정리해보겠습니다.

## 배포의 첫 걸음: 인프라 준비하기

### EC2 인스턴스 기반 배포

가장 기본적이면서도 직관적인 방법이 **EC2 인스턴스에 직접 배포**하는 것입니다. 마치 물리 서버에 배포하는 것과 비슷한데, 클라우드의 유연성까지 더해진 거죠.

```bash
# EC2 인스턴스 준비 과정
# 1. 보안 그룹 설정 (방화벽 규칙)
aws ec2 create-security-group --group-name web-server-sg --description "Web server security group"

# HTTP, HTTPS, SSH 포트 열기
aws ec2 authorize-security-group-ingress --group-name web-server-sg --protocol tcp --port 80 --cidr 0.0.0.0/0
aws ec2 authorize-security-group-ingress --group-name web-server-sg --protocol tcp --port 443 --cidr 0.0.0.0/0
aws ec2 authorize-security-group-ingress --group-name web-server-sg --protocol tcp --port 22 --cidr 0.0.0.0/0

# 2. 키 페어 생성 (SSH 접속용)
aws ec2 create-key-pair --key-name my-key-pair --query 'KeyMaterial' --output text > my-key-pair.pem
chmod 400 my-key-pair.pem

# 3. 인스턴스 시작
aws ec2 run-instances --image-id ami-0c02fb55956c7d316 --count 1 --instance-type t3.micro --key-name my-key-pair --security-groups web-server-sg
```


### Docker 기반 현대적 배포

요즘은 **Docker 컨테이너**를 사용한 배포가 거의 표준이 되었어요. 환경 일관성과 이식성 때문에 실무에서 선호하는 방식입니다.

```dockerfile
# Spring Boot 애플리케이션 Dockerfile
FROM openjdk:17-jre-slim

# 애플리케이션 사용자 생성 (보안 강화)
RUN groupadd -r appuser && useradd -r -g appuser appuser

WORKDIR /app
COPY target/*.jar app.jar

# 파일 소유권 변경
RUN chown -R appuser:appuser /app
USER appuser

# JVM 최적화 옵션
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC"

EXPOSE 8080
CMD ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```


## 실무에서 검증된 배포 전략들

### 1. 단순 배포 (In-Place Deployment)

**개발/테스트 환경**에서 주로 사용하는 가장 직접적인 방법입니다. 기존 애플리케이션을 중단하고 새 버전으로 교체하는 거죠.

```bash
#!/bin/bash
# 단순 배포 스크립트

echo "애플리케이션 중단 중..."
sudo systemctl stop myapp

echo "새 버전 배포 중..."
sudo cp target/myapp.jar /opt/myapp/
sudo chown appuser:appuser /opt/myapp/myapp.jar

echo "애플리케이션 시작 중..."
sudo systemctl start myapp

echo "헬스 체크..."
sleep 30
curl -f http://localhost:8080/actuator/health || exit 1
echo "배포 완료!"
```


### 2. 롤링 배포 (Rolling Deployment)

**무중단 배포**가 필요한 운영 환경에서는 롤링 배포를 사용합니다. 여러 인스턴스를 순차적으로 업데이트해서 서비스 중단 없이 배포하는 방식이에요.

```yaml
# AWS CodeDeploy 롤링 배포 설정
DeploymentConfig:
  Type: AWS::CodeDeploy::DeploymentConfig
  Properties:
    DeploymentConfigName: MyRollingDeployment
    MinimumHealthyHosts:
      Type: FLEET_PERCENT
      Value: 75  # 최소 75%의 인스턴스는 항상 가동 상태 유지
    TrafficRoutingConfig:
      Type: TimeBasedCanary
      TimeBasedCanaryConfig:
        CanaryPercentage: 10    # 처음에는 10%의 트래픽만
        CanaryInterval: 5       # 5분 대기 후 100%로 전환
```


### 3. 블루-그린 배포 (Blue-Green Deployment)

**완전한 무중단 배포**와 **빠른 롤백**이 필요한 중요한 서비스에서 사용하는 방식입니다. 두 개의 동일한 환경을 준비해두고 트래픽을 순간적으로 전환하는 거예요.

```bash
# 블루-그린 배포 스크립트 (ALB 사용)

# 현재 활성 환경 확인
CURRENT_ENV=$(aws elbv2 describe-rules --listener-arn $LISTENER_ARN --query 'Rules.Actions.TargetGroupArn' --output text)

if [[ $CURRENT_ENV == *"blue"* ]]; then
    ACTIVE_ENV="blue"
    STANDBY_ENV="green"
else
    ACTIVE_ENV="green"
    STANDBY_ENV="blue"
fi

echo "현재 활성 환경: $ACTIVE_ENV"
echo "배포 대상 환경: $STANDBY_ENV"

# Standby 환경에 새 버전 배포
aws ecs update-service --cluster myapp-cluster --service myapp-$STANDBY_ENV --task-definition myapp:$NEW_REVISION

# 배포 완료 대기
aws ecs wait services-stable --cluster myapp-cluster --services myapp-$STANDBY_ENV

# 헬스 체크
for i in {1..10}; do
    if curl -f http://$STANDBY_ENV.internal.myapp.com/health; then
        echo "Standby 환경 헬스 체크 통과"
        break
    fi
    sleep 10
done

# 트래픽 전환
aws elbv2 modify-rule --rule-arn $RULE_ARN --actions Type=forward,TargetGroupArn=$STANDBY_TARGET_GROUP

echo "트래픽 전환 완료: $ACTIVE_ENV -> $STANDBY_ENV"
```


## CI/CD 파이프라인: 자동화의 힘

### GitHub Actions를 활용한 배포 파이프라인

현대적인 개발 환경에서는 **코드 푸시부터 배포까지 모든 과정을 자동화**하는 것이 필수입니다.

```yaml
# .github/workflows/deploy.yml
name: Deploy to AWS

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Run tests
        run: ./mvnw clean test
      
      - name: Generate test report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Maven Tests
          path: target/surefire-reports/*.xml
          reporter: java-junit

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Build application
        run: ./mvnw clean package -DskipTests

      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .
          docker tag myapp:${{ github.sha }} ${{ secrets.ECR_REGISTRY }}/myapp:${{ github.sha }}
          docker tag myapp:${{ github.sha }} ${{ secrets.ECR_REGISTRY }}/myapp:latest

      - name: Push to ECR
        run: |
          aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}
          docker push ${{ secrets.ECR_REGISTRY }}/myapp:${{ github.sha }}
          docker push ${{ secrets.ECR_REGISTRY }}/myapp:latest

      - name: Deploy to ECS
        run: |
          # 새로운 태스크 정의 생성
          aws ecs register-task-definition --cli-input-json file://task-definition.json
          
          # 서비스 업데이트
          aws ecs update-service --cluster production-cluster --service myapp-service --task-definition myapp --force-new-deployment
          
          # 배포 완료 대기
          aws ecs wait services-stable --cluster production-cluster --services myapp-service

      - name: Verify deployment
        run: |
          # 헬스 체크
          sleep 60
          curl -f https://myapp.com/actuator/health
          
          # Slack 알림
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"🚀 배포 완료: '"${{ github.sha }}"'"}' \
            ${{ secrets.SLACK_WEBHOOK_URL }}
```


### AWS CodePipeline을 활용한 엔터프라이즈 배포

대규모 조직에서는 **AWS 네이티브 CI/CD 서비스**를 조합해서 사용하는 경우가 많아요.

```yaml
# buildspec.yml (CodeBuild 설정)
version: 0.2

phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      - REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME
      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - IMAGE_TAG=${COMMIT_HASH:=latest}
  
  build:
    commands:
      - echo Build started on `date`
      - echo Building the Docker image...
      - docker build -t $REPOSITORY_URI:latest .
      - docker tag $REPOSITORY_URI:latest $REPOSITORY_URI:$IMAGE_TAG
  
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Pushing the Docker images...
      - docker push $REPOSITORY_URI:latest
      - docker push $REPOSITORY_URI:$IMAGE_TAG
      - echo Writing image definitions file...
      - printf '[{"name":"myapp","imageUri":"%s"}]' $REPOSITORY_URI:$IMAGE_TAG > imagedefinitions.json

artifacts:
  files:
    - imagedefinitions.json
    - appspec.yml
    - taskdef.json
```


## 컨테이너 기반 배포: ECS와 EKS

### Amazon ECS로 간편한 컨테이너 관리

**ECS(Elastic Container Service)** 는 AWS에서 관리형으로 제공하는 컨테이너 오케스트레이션 서비스입니다. Kubernetes보다 학습 곡선이 낮으면서도 AWS 서비스와 긴밀하게 통합되어 있어요.

```json
// ECS 태스크 정의
{
  "family": "myapp",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "executionRoleArn": "arn:aws:iam::123456789012:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::123456789012:role/ecsTaskRole",
  "containerDefinitions": [
    {
      "name": "myapp",
      "image": "123456789012.dkr.ecr.ap-northeast-2.amazonaws.com/myapp:latest",
      "portMappings": [
        {
          "containerPort": 8080,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "SPRING_PROFILES_ACTIVE",
          "value": "production"
        }
      ],
      "secrets": [
        {
          "name": "DB_PASSWORD",
          "valueFrom": "arn:aws:secretsmanager:ap-northeast-2:123456789012:secret:prod/db/password"
        }
      ],
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 60
      },
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/myapp",
          "awslogs-region": "ap-northeast-2",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```


### Kubernetes와 EKS

더 복잡한 마이크로서비스 환경이나 멀티클라우드 전략을 고려한다면 **EKS(Elastic Kubernetes Service)** 를 선택할 수 있습니다. Kubernetes의 강력함과 AWS의 관리 편의성을 모두 얻을 수 있어요.

```yaml
# Kubernetes 배포 매니페스트
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: production
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: 123456789012.dkr.ecr.ap-northeast-2.amazonaws.com/myapp:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "production"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
```


## 모니터링과 로깅: 배포 후 관리

### CloudWatch를 활용한 통합 모니터링

배포가 끝났다고 모든 게 끝난 건 아닙니다. **지속적인 모니터링**이 있어야 안정적인 서비스 운영이 가능해요.

```python
# CloudWatch 커스텀 메트릭 전송 예시
import boto3
import time
from datetime import datetime

cloudwatch = boto3.client('cloudwatch')

def put_custom_metric(metric_name, value, unit='Count'):
    try:
        cloudwatch.put_metric_data(
            Namespace='MyApp/Business',
            MetricData=[
                {
                    'MetricName': metric_name,
                    'Value': value,
                    'Unit': unit,
                    'Timestamp': datetime.utcnow()
                }
            ]
        )
    except Exception as e:
        print(f"메트릭 전송 실패: {e}")

# 사용 예시
put_custom_metric('OrderCount', 150)
put_custom_metric('Revenue', 50000, 'None')
```


### 알람 설정으로 선제적 대응

```json
// CloudWatch 알람 설정
{
  "AlarmName": "HighErrorRate",
  "AlarmDescription": "API 에러율이 5%를 초과했을 때",
  "MetricName": "ErrorRate",
  "Namespace": "AWS/ApplicationELB",
  "Statistic": "Average",
  "Period": 300,
  "EvaluationPeriods": 2,
  "Threshold": 5.0,
  "ComparisonOperator": "GreaterThanThreshold",
  "AlarmActions": [
    "arn:aws:sns:ap-northeast-2:123456789012:emergency-alerts"
  ],
  "Dimensions": [
    {
      "Name": "LoadBalancer",
      "Value": "app/myapp-alb/50dc6c495c0c9188"
    }
  ]
}
```


## 마무리

AWS 배포 과정을 정리해보니, 단순히 코드를 서버에 올리는 것 이상의 많은 고려사항들이 있다는 걸 알 수 있어요. **인프라 구성부터 모니터링까지**, 전체 생명주기를 고려한 접근이 필요합니다.

특히 현업에서는 **"배포했다고 끝이 아니라 시작"** 이라는 말을 자주 듣게 될 거예요. 실제로는 배포 후의 운영, 모니터링, 문제 해결이 더 중요하고 시간도 많이 걸리거든요.

AWS는 이런 전체 과정을 지원하는 다양한 도구들을 제공합니다. 처음에는 복잡해 보이지만, 하나씩 익숙해지다 보면 이보다 강력한 플랫폼은 없다는 걸 느끼게 될 거예요. 중요한 건 **작은 것부터 시작해서 점진적으로 복잡성을 늘려가는 것**입니다.

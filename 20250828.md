# AOP

## 왜 AOP가 필요할까?

웹 애플리케이션을 개발하다 보면 비슷한 코드가 곳곳에 반복된다. 로깅, 보안 검사, 트랜잭션 처리 같은 것들 말이다.

```java
public void saveUser(User user) {
    logger.info("saveUser 메서드 시작");
    
    if (!hasPermission()) {
        throw new SecurityException("권한 없음");
    }
    
    try {
        transactionManager.begin();
        userRepository.save(user);
        transactionManager.commit();
        logger.info("사용자 저장 완료");
    } catch (Exception e) {
        transactionManager.rollback();
        logger.error("사용자 저장 실패", e);
        throw e;
    }
}
```

이런 코드가 모든 메서드에 있다면? 정말 지겨워진다. 핵심 비즈니스 로직은 `userRepository.save(user)` 한 줄뿐인데, 나머지는 모두 부가 기능이다.

AOP는 바로 이런 문제를 해결한다. 핵심 로직과 부가 기능을 분리해서, 코드를 훨씬 깔끔하게 만들어준다.

## AOP의 핵심 개념들

### 관심사의 분리

**핵심 관심사**는 우리가 정말 해결하려는 비즈니스 로직이다. 사용자 저장, 주문 처리, 결제 같은 것들.

**횡단 관심사**는 여러 모듈에서 공통으로 필요한 기능들이다. 로깅, 보안, 캐싱, 성능 측정 등이 여기에 해당한다.

```
[사용자 관리] [주문 처리] [결제 처리]
      |           |           |
    ===================================
    |        로깅, 보안, 트랜잭션        |  ← 횡단 관심사
    ===================================
```


### Aspect, Advice, Pointcut

**Aspect**는 횡단 관심사를 모듈화한 것이다. 로깅 Aspect, 보안 Aspect 이런 식으로 만든다.

**Advice**는 실제로 수행할 동작이다. "메서드 실행 전에 로그를 남겨라" 같은 것.

**Pointcut**은 어디에 적용할지 정의한다. "UserService의 모든 public 메서드에" 같은 조건을 설정한다.

## Spring AOP 실전 활용

### 기본 로깅 Aspect

```java
@Aspect
@Component
public class LoggingAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);
    
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        logger.info("{}#{} 메서드 호출", className, methodName);
    }
    
    @AfterReturning(pointcut = "execution(* com.example.service.*.*(..))", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("{}#{} 메서드 완료, 결과: {}", 
                   joinPoint.getTarget().getClass().getSimpleName(), 
                   methodName, result);
    }
    
    @AfterThrowing(pointcut = "execution(* com.example.service.*.*(..))", throwing = "error")
    public void logAfterThrowing(JoinPoint joinPoint, Throwable error) {
        logger.error("{}#{} 메서드에서 예외 발생: {}", 
                    joinPoint.getTarget().getClass().getSimpleName(),
                    joinPoint.getSignature().getName(), 
                    error.getMessage());
    }
}
```

이제 서비스 클래스는 이렇게 깔끔해진다:

```java
@Service
public class UserService {
    
    public void saveUser(User user) {
        userRepository.save(user);  // 핵심 로직만!
    }
}
```


### 성능 측정 Aspect

```java
@Aspect
@Component
public class PerformanceAspect {
    
    @Around("@annotation(Timed)")
    public Object measureTime(ProceedingJoinPoint pjp) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = pjp.proceed();
            long endTime = System.currentTimeMillis();
            
            logger.info("{}#{} 실행시간: {}ms", 
                       pjp.getTarget().getClass().getSimpleName(),
                       pjp.getSignature().getName(), 
                       endTime - startTime);
            
            return result;
        } catch (Exception e) {
            long endTime = System.currentTimeMillis();
            logger.warn("{}#{} 실행시간: {}ms (예외 발생)", 
                       pjp.getTarget().getClass().getSimpleName(),
                       pjp.getSignature().getName(), 
                       endTime - startTime);
            throw e;
        }
    }
}
```

사용할 때는 어노테이션만 붙이면 된다:

```java
@Service
public class OrderService {
    
    @Timed
    public Order processOrder(OrderRequest request) {
        // 복잡한 주문 처리 로직
        return order;
    }
}
```


### 권한 검사 Aspect

```java
@Aspect
@Component
public class SecurityAspect {
    
    @Before("@annotation(RequirePermission)")
    public void checkPermission(JoinPoint joinPoint) {
        RequirePermission annotation = getAnnotation(joinPoint);
        String requiredRole = annotation.value();
        
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (!hasRole(auth, requiredRole)) {
            throw new SecurityException("권한이 부족합니다: " + requiredRole);
        }
    }
    
    private RequirePermission getAnnotation(JoinPoint joinPoint) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        return signature.getMethod().getAnnotation(RequirePermission.class);
    }
}
```


## Pointcut 표현식 정리

AOP를 제대로 쓰려면 Pointcut 표현식을 알아야 한다.

### 메서드 실행 기준

```java
// 모든 public 메서드
@Before("execution(public * *(..))")

// UserService의 모든 메서드
@Before("execution(* com.example.UserService.*(..))")

// Service로 끝나는 클래스의 모든 메서드
@Before("execution(* com.example.*Service.*(..))")

// 반환 타입이 String인 메서드
@Before("execution(String *(..))")
```


### 어노테이션 기준

```java
// @Transactional이 붙은 메서드
@Before("@annotation(org.springframework.transaction.annotation.Transactional)")

// @Service가 붙은 클래스의 모든 메서드
@Before("@within(org.springframework.stereotype.Service)")
```


### 파라미터 기준

```java
// 파라미터가 없는 메서드
@Before("execution(* *())")

// String 파라미터 하나를 받는 메서드
@Before("execution(* *(String))")

// 첫 번째 파라미터가 User인 메서드
@Before("execution(* *(com.example.User, ..))")
```


## Advice 타입별 활용법

### @Before - 사전 검증

메서드 실행 전에 뭔가 확인하거나 준비하는 용도다.

```java
@Before("execution(* com.example.service.*.*(..))")
public void validateInput(JoinPoint joinPoint) {
    Object[] args = joinPoint.getArgs();
    for (Object arg : args) {
        if (arg == null) {
            throw new IllegalArgumentException("파라미터가 null입니다");
        }
    }
}
```


### @After - 정리 작업

메서드가 끝난 후 무조건 실행된다. 예외가 발생해도 실행된다.

```java
@After("execution(* com.example.service.*.*(..))")
public void cleanup() {
    // 임시 파일 삭제, 연결 정리 등
    ThreadLocalCache.clear();
}
```


### @Around - 전체 제어

메서드 실행 전후를 모두 제어할 수 있다. 가장 강력하지만 조심해서 써야 한다.

```java
@Around("@annotation(Cacheable)")
public Object cacheResult(ProceedingJoinPoint pjp) throws Throwable {
    String key = generateCacheKey(pjp);
    
    Object cached = cache.get(key);
    if (cached != null) {
        return cached;
    }
    
    Object result = pjp.proceed();
    cache.put(key, result);
    return result;
}
```


## 실무에서 자주 쓰이는 AOP 패턴

### API 응답시간 모니터링

```java
@Aspect
@Component
public class ApiMonitoringAspect {
    
    @Around("@within(org.springframework.web.bind.annotation.RestController)")
    public Object monitorApi(ProceedingJoinPoint pjp) throws Throwable {
        String apiName = pjp.getSignature().getName();
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = pjp.proceed();
            long responseTime = System.currentTimeMillis() - startTime;
            
            // 모니터링 시스템에 전송
            sendMetrics(apiName, responseTime, "SUCCESS");
            
            return result;
        } catch (Exception e) {
            long responseTime = System.currentTimeMillis() - startTime;
            sendMetrics(apiName, responseTime, "ERROR");
            throw e;
        }
    }
}
```


### 데이터베이스 쿼리 로깅

```java
@Aspect
@Component
public class DatabaseLoggingAspect {
    
    @Around("execution(* com.example.repository.*.*(..))")
    public Object logDatabaseAccess(ProceedingJoinPoint pjp) throws Throwable {
        String methodName = pjp.getSignature().getName();
        Object[] args = pjp.getArgs();
        
        logger.debug("DB 접근: {} - 파라미터: {}", methodName, Arrays.toString(args));
        
        long startTime = System.currentTimeMillis();
        Object result = pjp.proceed();
        long queryTime = System.currentTimeMillis() - startTime;
        
        logger.debug("DB 쿼리 완료: {}ms", queryTime);
        
        if (queryTime > 1000) {
            logger.warn("느린 쿼리 감지: {} - {}ms", methodName, queryTime);
        }
        
        return result;
    }
}
```


## AOP 사용 시 주의사항

### 성능 오버헤드

AOP는 프록시나 바이트코드 조작을 사용하므로 약간의 성능 오버헤드가 있다. 매우 자주 호출되는 메서드에는 신중하게 적용해야 한다.

### 디버깅의 어려움

코드상에서는 보이지 않는 로직이 실행되므로 디버깅이 어려울 수 있다. 로그를 충분히 남기고, AOP가 언제 실행되는지 명확히 파악해야 한다.

### Self-Invocation 문제

같은 클래스 내에서 메서드를 호출할 때는 AOP가 적용되지 않는다.

```java
@Service
public class UserService {
    
    @Transactional
    public void saveUser(User user) {
        // 내부 호출에서는 @Transactional이 동작하지 않음
        this.updateUserStats(user);
    }
    
    @Transactional
    public void updateUserStats(User user) {
        // ...
    }
}
```

이럴 때는 별도의 서비스로 분리하거나, `@Autowired`로 자기 자신을 주입받아야 한다.

## 언제 AOP를 써야 할까?

AOP는 만능이 아니다. 적절한 상황에서만 써야 한다.

**AOP가 적합한 경우:**

- 로깅, 모니터링, 성능 측정
- 보안 검사, 권한 확인
- 트랜잭션 처리
- 캐싱
- 에러 핸들링

**AOP를 피해야 하는 경우:**

- 핵심 비즈니스 로직
- 복잡한 조건부 로직
- 순서가 중요한 처리

결국 AOP는 "반복되는 부가 기능"을 깔끔하게 분리하는 도구다. 남용하면 코드가 더 복잡해질 수 있지만, 적절히 사용하면 코드 품질과 유지보수성을 크게 높일 수 있다.

핵심은 **관심사의 분리**다. 진짜 중요한 비즈니스 로직에 집중할 수 있게 해주는 것, 그게 AOP의 진짜 가치다.


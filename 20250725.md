
# JDBC: Java와 데이터베이스를 잇는 다리

데이터베이스 없는 애플리케이션은 상상하기 어렵죠. 그런데 Java 프로그램에서 데이터베이스에 접근하려면 어떻게 해야 할까요? 바로 **JDBC(Java Database Connectivity)** 가 그 해답입니다. JDBC는 Java 애플리케이션이 데이터베이스와 소통할 수 있게 해주는 표준 인터페이스로, 마치 서로 다른 언어를 사용하는 사람들 사이의 통역사 같은 역할을 합니다.

## JDBC란 무엇인가?

JDBC는 **Java Database Connectivity**의 줄임말로, Sun Microsystems(현재 Oracle)에서 만든 Java 표준 API입니다. 쉽게 말해서 Java 프로그램이 어떤 종류의 데이터베이스든 상관없이 일관된 방식으로 접근할 수 있게 해주는 **공통 인터페이스**라고 보면 됩니다.

예를 들어, MySQL을 사용하다가 PostgreSQL로 바꾸게 되더라도 JDBC 덕분에 코드의 핵심 부분은 거의 그대로 사용할 수 있어요. 물론 SQL 문법의 차이는 있겠지만, 데이터베이스에 연결하고 쿼리를 실행하는 기본적인 패턴은 동일하게 유지됩니다.

**JDBC의 동작 원리**

JDBC는 **4단계 아키텍처**로 구성되어 있습니다. Java 애플리케이션이 가장 위에 있고, 그 다음이 JDBC API, 그리고 JDBC Driver Manager, 마지막으로 실제 데이터베이스와 통신하는 JDBC Driver가 있어요.

이런 구조 덕분에 개발자는 복잡한 데이터베이스별 통신 프로토콜을 알 필요 없이, 표준화된 JDBC API만 사용하면 됩니다. 실제 데이터베이스와의 구체적인 통신은 각 데이터베이스 벤더가 제공하는 JDBC Driver가 담당하죠.

## JDBC의 핵심 삼총사: Connection, Statement, ResultSet

JDBC API를 사용해서 데이터베이스 작업을 할 때 만나게 되는 가장 중요한 세 객체가 있습니다. 이들은 서로 긴밀하게 협력해서 데이터베이스 연동의 전 과정을 처리해요.

### Connection 객체: 데이터베이스와의 연결 통로

**Connection**은 말 그대로 Java 애플리케이션과 데이터베이스 사이의 **연결(Connection)** 을 나타내는 객체입니다. 전화를 걸 때 상대방과 연결되는 것처럼, 데이터베이스 작업을 하기 전에 반드시 Connection을 먼저 확보해야 해요.

```java
String url = "jdbc:mysql://localhost:3306/mydb";
String username = "user";
String password = "password";

Connection connection = DriverManager.getConnection(url, username, password);
```

Connection 객체를 통해서 할 수 있는 주요 작업들을 살펴보면, 가장 기본적으로는 **Statement 객체를 생성**하는 것입니다. SQL을 실행하려면 Statement가 필요하거든요.

또한 **트랜잭션 관리**도 Connection의 중요한 역할입니다. `setAutoCommit(false)`로 자동 커밋을 끄고, 명시적으로 `commit()`이나 `rollback()`을 호출해서 트랜잭션을 제어할 수 있어요. 이는 여러 개의 SQL 문을 하나의 논리적 단위로 묶어서 처리할 때 꼭 필요한 기능입니다.

Connection은 **값비싼 자원**입니다. 데이터베이스 서버에서도 연결 수에 제한이 있고, 네트워크 리소스도 사용하죠. 그래서 사용이 끝나면 반드시 `close()` 메서드로 연결을 해제해야 합니다.

### Statement 객체: SQL 실행의 전령사

**Statement**는 SQL 문을 실행하기 위한 객체입니다. Connection이 연결 통로라면, Statement는 그 통로를 통해 실제로 명령을 전달하는 **전령사** 역할을 한다고 보면 됩니다.

Statement에는 세 가지 주요 종류가 있어요. 가장 기본적인 **Statement**는 정적인 SQL 문을 실행할 때 사용합니다. 하지만 실무에서는 보안상 이유로 잘 사용하지 않죠.

```java
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users WHERE age > 25");
```

**PreparedStatement**는 미리 컴파일된 SQL 문을 실행하는 객체입니다. 가장 많이 사용되는 방식이기도 해요. 매개변수를 `?` 플레이스홀더로 표시하고, 나중에 실제 값을 바인딩하는 방식으로 동작합니다.

```java
PreparedStatement pstmt = connection.prepareStatement(
    "SELECT * FROM users WHERE age > ? AND city = ?");
pstmt.setInt(1, 25);
pstmt.setString(2, "Seoul");
ResultSet rs = pstmt.executeQuery();
```

PreparedStatement의 장점은 **SQL Injection 공격을 방지**할 수 있고, **성능도 더 좋다**는 점입니다. 같은 구조의 SQL을 반복 실행할 때 컴파일 과정을 생략할 수 있거든요.

**CallableStatement**는 저장 프로시저를 호출할 때 사용하는 특수한 Statement입니다. 일반적인 웹 애플리케이션에서는 자주 사용하지 않지만, 복잡한 비즈니스 로직이 데이터베이스에 저장되어 있는 경우에 필요해요.

Statement의 주요 메서드들을 살펴보면, `executeQuery()`는 SELECT 문처럼 결과를 반환하는 쿼리에 사용하고, `executeUpdate()`는 INSERT, UPDATE, DELETE 같이 데이터를 변경하는 쿼리에 사용합니다. `execute()`는 어떤 종류의 SQL이든 실행할 수 있는 범용 메서드예요.

### ResultSet 객체: 쿼리 결과의 수호자

**ResultSet**은 SELECT 쿼리의 실행 결과를 담고 있는 객체입니다. 데이터베이스에서 가져온 행들을 하나씩 순차적으로 읽을 수 있게 해주는 **커서(Cursor)** 같은 역할을 합니다.

```java
ResultSet rs = pstmt.executeQuery();
while (rs.next()) {
    int id = rs.getInt("user_id");
    String name = rs.getString("username");
    Date regDate = rs.getDate("reg_date");
    
    System.out.println("ID: " + id + ", Name: " + name + ", Date: " + regDate);
}
```

ResultSet의 동작 방식은 꽤 독특합니다. 처음에는 **첫 번째 행의 앞**에 위치해 있어서, `next()` 메서드를 호출해야 실제 데이터가 있는 첫 번째 행으로 이동합니다. 그래서 보통 `while (rs.next())` 패턴으로 모든 행을 순회하죠.

데이터를 가져올 때는 컬럼명이나 인덱스를 사용할 수 있어요. `rs.getString("username")`처럼 컬럼명을 사용하는 것이 가독성 면에서 더 좋지만, `rs.getString(2)`처럼 인덱스를 사용하는 것이 성능상으로는 약간 더 유리합니다.

**주의할 점**은 ResultSet도 Connection과 마찬가지로 **리소스를 사용하는 객체**라는 것입니다. 특히 대용량 결과 집합의 경우 메모리를 많이 사용할 수 있어서, 사용이 끝나면 반드시 `close()` 메서드로 해제해야 해요.

## JDBC 사용 시 꼭 지켜야 할 원칙들

### 리소스 관리의 철칙

JDBC를 사용할 때 가장 중요한 것은 **리소스 관리**입니다. Connection, Statement, ResultSet은 모두 사용 후 반드시 해제해야 하는 자원들이에요. Java 7부터는 try-with-resources 구문을 사용해서 자동으로 리소스를 해제할 수 있습니다.

```java
try (Connection conn = DriverManager.getConnection(url, user, password);
     PreparedStatement pstmt = conn.prepareStatement(sql);
     ResultSet rs = pstmt.executeQuery()) {
    
    while (rs.next()) {
        // 결과 처리
    }
} catch (SQLException e) {
    e.printStackTrace();
}
// 자동으로 리소스가 해제됨
```


### 예외 처리의 중요성

데이터베이스 작업은 네트워크 문제, 권한 문제, SQL 문법 오류 등 다양한 이유로 실패할 수 있습니다. 그래서 **적절한 예외 처리**가 매우 중요해요. SQLException은 checked exception이므로 반드시 처리해야 하고, 가능하면 구체적인 오류 정보를 로깅하는 것이 좋습니다.

### 성능 최적화 팁

실무에서 JDBC를 사용할 때는 성능도 고려해야 합니다. **Connection Pool**을 사용해서 연결 생성 비용을 줄이고, **Batch 처리**로 여러 개의 INSERT나 UPDATE를 한 번에 처리하는 것이 효과적이에요.

또한 적절한 **fetch size**를 설정해서 네트워크 왕복 횟수를 줄이고, 필요한 컬럼만 SELECT하는 것도 성능 향상에 도움이 됩니다.

JDBC는 Java 개발자라면 반드시 알아야 할 기본기 중 하나입니다. 최근에는 JPA나 MyBatis 같은 고수준 프레임워크를 많이 사용하지만, 이들도 결국 내부적으로는 JDBC를 사용하고 있어요. 그래서 JDBC의 동작 원리를 이해하고 있으면 문제 해결이나 성능 튜닝에서 큰 도움이 됩니다.

## 느낀 점
- jdbc를 초반에 쓰고 jpa나 mybatis 쓰느라 기억이 가물가물해졌는데 동작 원리를 이해하고 틈틈이 복습해야겠다고 생각했다.
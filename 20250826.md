# Apache Kafka

## 왜 Kafka인가?

기존의 메시징 시스템들은 규모가 커질수록 병목이 생기기 마련이다. 수백만 건의 메시지를 초당 처리해야 하는 상황에서, 기존 솔루션들은 한계를 드러낸다. LinkedIn에서 이런 문제를 해결하기 위해 만든 것이 바로 Kafka다.

Kafka는 단순히 메시지 큐가 아니라 **분산 스트리밍 플랫폼**이다. 실시간으로 흐르는 데이터를 안정적으로 저장하고, 여러 시스템 간에 효율적으로 전달하는 것이 핵심 목표다.

## 핵심 개념들

### Producer와 Consumer

**Producer**는 데이터를 Kafka에 보내는 애플리케이션이다. 웹 서버 로그, 사용자 행동 데이터, 센서 데이터 등을 Kafka로 전송한다.

**Consumer**는 Kafka에서 데이터를 읽어가는 애플리케이션이다. 실시간 분석 시스템, 데이터베이스 동기화 프로세스, 알림 시스템 등이 Consumer가 될 수 있다.

### Topic과 Partition

**Topic**은 데이터를 논리적으로 구분하는 단위다. 예를 들어 `user-activity`, `order-events`, `system-logs` 같은 식으로 나눈다.

**Partition**은 Topic을 물리적으로 나누는 방법이다. 하나의 Topic을 여러 Partition으로 나누면 병렬 처리가 가능해진다. 각 Partition은 순서가 보장되는 불변의 로그 구조다.

```
Topic: user-activity
├── Partition 0: [msg1, msg2, msg3, ...]
├── Partition 1: [msg4, msg5, msg6, ...]
└── Partition 2: [msg7, msg8, msg9, ...]
```


### Broker와 Cluster

**Broker**는 Kafka 서버 하나를 의미한다. 실제 데이터를 저장하고 Client의 요청을 처리한다.

**Cluster**는 여러 Broker들이 모여서 하나의 Kafka 시스템을 구성하는 것이다. Broker가 죽어도 다른 Broker들이 서비스를 계속할 수 있다.

## 왜 빠른가?

### Sequential I/O

Kafka는 디스크에 데이터를 순차적으로 쓴다. 랜덤 I/O보다 순차 I/O가 훨씬 빠르다는 것을 활용한 설계다. 심지어 메모리보다 디스크 순차 쓰기가 더 빠른 경우도 있다.

### Zero-Copy

데이터를 Consumer에게 전달할 때 불필요한 복사를 최소화한다. OS의 sendfile() 시스템콜을 사용해서 커널 공간에서 직접 네트워크로 데이터를 전송한다.

### Batch Processing

메시지를 하나씩 처리하지 않고 배치로 묶어서 처리한다. 네트워크 오버헤드를 줄이고 처리량을 높인다.

## 내구성과 신뢰성

### Replication

각 Partition은 여러 Broker에 복제된다. Leader Partition과 Follower Partition이 있어서, Leader가 죽으면 Follower 중 하나가 새로운 Leader가 된다.

### Acknowledgment

Producer는 메시지 전송 후 ack를 받을 수 있다:

- `acks=0`: 전송 후 응답 안 기다림 (빠르지만 유실 가능)
- `acks=1`: Leader만 받으면 응답 (일반적)
- `acks=all`: 모든 replica가 받으면 응답 (안전하지만 느림)


## 실제 사용 패턴

### Event Sourcing

모든 상태 변경을 이벤트로 기록한다. 계좌 잔액을 저장하는 대신 입금/출금 이벤트들을 저장하는 식이다.

### CQRS (Command Query Responsibility Segregation)

쓰기용 시스템과 읽기용 시스템을 분리한다. Kafka가 중간에서 데이터를 전달하는 역할을 한다.

### 실시간 처리 파이프라인

```
데이터 소스 → Kafka → Stream Processing → 저장소/알림
```

웹 로그를 실시간으로 분석해서 이상 패턴을 감지하거나, 사용자 행동을 분석해서 개인화 추천을 만드는 등의 용도로 쓴다.

## 운영 시 주의사항

### Partition 개수

Partition을 너무 많이 만들면 메타데이터 오버헤드가 커진다. 너무 적게 만들면 병렬성이 떨어진다. Consumer 개수와 처리량을 고려해서 적절히 설정해야 한다.

### Consumer Group

같은 Consumer Group 내의 Consumer들은 Partition을 나눠서 처리한다. Consumer가 3개인데 Partition이 5개면 2개 Consumer가 일을 더 한다.

### Offset 관리

Consumer가 어디까지 읽었는지 기록하는 것이 Offset이다. 잘못 관리하면 메시지를 중복 처리하거나 유실할 수 있다.

## 한계와 고려사항

Kafka는 만능이 아니다. 메시지 순서가 중요한 경우 Partition 설계를 신중히 해야 하고, 작은 규모에서는 오히려 복잡할 수 있다.

또한 Consumer가 느리면 Lag이 쌓이는데, 이를 모니터링하고 관리하는 것이 중요하다. 디스크 용량 관리도 필요하다 - 데이터를 얼마나 오래 보관할지 retention policy를 잘 설정해야 한다.

결국 Kafka는 대용량 실시간 데이터 처리가 필요한 곳에서 진가를 발휘한다. 마이크로서비스 간 비동기 통신, 실시간 분석, 데이터 파이프라인 구축 등에서 없어서는 안 될 도구가 되었다.


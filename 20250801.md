
# 객체 지향 프로그래밍의 4가지 핵심 원칙

객체 지향 프로그래밍을 제대로 이해하려면 4가지 핵심 원칙을 알아야 합니다. 이 원칙들은 단순히 이론적인 개념이 아니라, 실제 개발에서 코드의 품질과 유지보수성을 좌우하는 실용적인 가이드라인입니다.

## 캡슐화: 데이터를 안전하게 보호하기

캡슐화는 **객체의 내부 구현을 숨기고 외부에서는 정해진 방법으로만 접근할 수 있게 하는 것**입니다. 마치 약을 캡슐에 넣어서 직접 손대지 못하게 하는 것과 같다고 생각하면 됩니다.

```java
public class User {
    private String password;  // 외부에서 직접 접근 불가
    private String email;
    
    // 안전한 방법으로만 접근 허용
    public void setPassword(String password) {
        if (password != null && password.length() >= 8) {
            this.password = BCrypt.hashpw(password, BCrypt.gensalt());
        }
    }
    
    public boolean verifyPassword(String inputPassword) {
        return BCrypt.checkpw(inputPassword, this.password);
    }
}
```

이렇게 하면 외부에서 `user.password = "123"`처럼 무분별하게 접근할 수 없고, 반드시 검증과 암호화를 거친 안전한 방법으로만 비밀번호를 설정할 수 있습니다. Spring Boot에서 `@Entity` 클래스를 만들 때도 필드를 `private`로 선언하고 getter/setter를 통해 접근하는 것이 바로 캡슐화의 실제 적용 사례입니다.

## 상속: 코드 재사용의 마법

상속은 **기존 클래스의 특성을 물려받아서 새로운 클래스를 만드는 것**입니다. 부모가 가진 재산을 자식이 물려받는 것처럼, 부모 클래스의 속성과 메서드를 자식 클래스가 그대로 사용할 수 있습니다.

```java
// 부모 클래스
public abstract class Animal {
    protected String name;
    protected int age;
    
    public void eat() {
        System.out.println(name + "이(가) 먹고 있습니다.");
    }
    
    public abstract void makeSound();  // 자식이 반드시 구현해야 함
}

// 자식 클래스
public class Dog extends Animal {
    private String breed;
    
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
    
    public void fetch() {  // Dog만의 고유 기능
        System.out.println(name + "이(가) 공을 가져옵니다.");
    }
}
```

JPA에서 `@Entity` 클래스들이 공통 필드(`id`, `createdAt`, `updatedAt` 등)를 가질 때 `BaseEntity`를 만들고 상속받는 것도 같은 원리입니다. 중복 코드를 줄이고 일관성을 유지할 수 있죠.

## 다형성: 하나의 인터페이스, 여러 형태

다형성은 **같은 인터페이스나 부모 클래스 타입으로 서로 다른 구현체들을 동일하게 다룰 수 있는 것**입니다. 리모컨의 전원 버튼을 누르면 TV든 에어컨이든 모두 켜지는 것처럼, 같은 메서드 호출로 다른 동작을 할 수 있습니다.

```java
public interface PaymentProcessor {
    PaymentResult process(PaymentRequest request);
}

public class CreditCardProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(PaymentRequest request) {
        // 신용카드 결제 로직
        return new PaymentResult("신용카드 결제 완료");
    }
}

public class KakaoPayProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(PaymentRequest request) {
        // 카카오페이 결제 로직
        return new PaymentResult("카카오페이 결제 완료");
    }
}

// 사용하는 쪽에서는 구체적인 구현체를 몰라도 됨
public class PaymentService {
    public void processPayment(PaymentProcessor processor, PaymentRequest request) {
        PaymentResult result = processor.process(request);  // 다형성!
        // processor가 어떤 구현체든 상관없이 동일하게 호출 가능
    }
}
```

Spring에서 `@Autowired`로 인터페이스를 주입받으면 런타임에 실제 구현체가 결정되는 것도 다형성의 활용입니다. 테스트할 때는 Mock 객체를, 운영할 때는 실제 구현체를 주입할 수 있죠.

## 추상화: 복잡함을 단순하게

추상화는 **복잡한 구현 세부사항은 숨기고 중요한 특징이나 기능만을 노출하는 것**입니다. 자동차를 운전할 때 엔진의 내부 구조를 알 필요 없이 엑셀과 브레이크만 알면 되는 것과 같습니다.

```java
// 추상화된 서비스 인터페이스
public interface UserService {
    User createUser(UserCreateRequest request);
    User getUserById(Long id);
    void deleteUser(Long id);
}

// 복잡한 구현 세부사항은 내부에 숨김
@Service
public class UserServiceImpl implements UserService {
    
    @Override
    public User createUser(UserCreateRequest request) {
        // 1. 입력값 검증
        validateUserRequest(request);
        
        // 2. 중복 체크
        checkDuplicateEmail(request.getEmail());
        
        // 3. 비밀번호 암호화
        String encryptedPassword = encryptPassword(request.getPassword());
        
        // 4. 데이터베이스 저장
        User user = User.builder()
            .name(request.getName())
            .email(request.getEmail())
            .password(encryptedPassword)
            .build();
            
        return userRepository.save(user);
    }
    
    // 복잡한 내부 구현 메서드들...
    private void validateUserRequest(UserCreateRequest request) { /* ... */ }
    private void checkDuplicateEmail(String email) { /* ... */ }
    private String encryptPassword(String password) { /* ... */ }
}
```

Controller에서는 `userService.createUser(request)`만 호출하면 되고, 내부에서 어떤 복잡한 과정을 거치는지 알 필요가 없습니다. 이것이 추상화의 힘입니다.

## 마무리

이 4가지 원칙은 서로 독립적이 아니라 함께 작용합니다. Spring Boot로 REST API를 개발할 때를 생각해보면:

**캡슐화**로 Entity의 내부 상태를 보호하고, **상속**으로 공통 기능을 재사용하며, **다형성**으로 다양한 구현체를 유연하게 교체할 수 있고, **추상화**로 복잡한 비즈니스 로직을 깔끔한 인터페이스 뒤에 숨길 수 있습니다.

결국 이 원칙들의 목표는 하나입니다. **변경에 유연하고, 확장에 열려있으며, 이해하기 쉬운 코드**를 만드는 것이죠. 처음에는 복잡해 보일 수 있지만, 프로젝트가 커질수록 이 원칙들의 진가를 실감하게 됩니다.

